// Autogenerated by Thrift Compiler (0.9.3)
// DO NOT EDIT UNLESS YOU ARE SURE THAT YOU KNOW WHAT YOU ARE DOING

package file_system_worker

import (
	"bytes"
	"common"
	"exception"
	"fmt"
	"git.apache.org/thrift.git/lib/go/thrift"
)

// (needed to ensure safety because of naive import list construction.)
var _ = thrift.ZERO
var _ = fmt.Printf
var _ = bytes.Equal

var _ = common.GoUnusedProtection__
var _ = exception.GoUnusedProtection__

type FileSystemWorkerClientService interface {
	common.AlluxioService
	//This interface contains file system worker service endpoints for Alluxio clients.

	// Cancels a file which has not been completed in the under file system.
	//
	// Parameters:
	//  - SessionId: the id of the current session
	//  - TempUfsFileId: the worker specific file id of the ufs file
	//  - Options: the options for canceling the file
	CancelUfsFile(sessionId int64, tempUfsFileId int64, options *CancelUfsFileTOptions) (err error)
	// Closes a file in the under file system which was previously opened for reading.
	//
	//
	// Parameters:
	//  - SessionId: the id of the current session
	//  - TempUfsFileId: the worker specific file id of the ufs file
	//  - Options: the options for closing the file
	CloseUfsFile(sessionId int64, tempUfsFileId int64, options *CloseUfsFileTOptions) (err error)
	// Completes a file in the under file system.
	//
	// Parameters:
	//  - SessionId: the id of the current session
	//  - TempUfsFileId: the worker specific file id of the ufs file
	//  - Options: the options for completing the file
	CompleteUfsFile(sessionId int64, tempUfsFileId int64, options *CompleteUfsFileTOptions) (r int64, err error)
	// Creates a file in the under file system.
	//
	// Parameters:
	//  - SessionId: the id of the current session
	//  - UfsPath: the path of the file in the ufs
	//  - Options: the options for creating the file
	CreateUfsFile(sessionId int64, ufsPath string, options *CreateUfsFileTOptions) (r int64, err error)
	// Opens an existing file in the under file system for reading.
	//
	// Parameters:
	//  - SessionId: the id of the current session
	//  - UfsPath: the path of the file in the ufs
	//  - Options: the options for opening the file
	OpenUfsFile(sessionId int64, ufsPath string, options *OpenUfsFileTOptions) (r int64, err error)
	// Local session send heartbeat to local worker to keep its state. It also can be used to send
	// client metrics to the worker.
	//
	// Parameters:
	//  - SessionId: the id of the current session
	//  - Metrics: the client metrics
	SessionHeartbeat(sessionId int64, metrics []int64) (err error)
}

//This interface contains file system worker service endpoints for Alluxio clients.
type FileSystemWorkerClientServiceClient struct {
	*common.AlluxioServiceClient
}

func NewFileSystemWorkerClientServiceClientFactory(t thrift.TTransport, f thrift.TProtocolFactory) *FileSystemWorkerClientServiceClient {
	return &FileSystemWorkerClientServiceClient{AlluxioServiceClient: common.NewAlluxioServiceClientFactory(t, f)}
}

func NewFileSystemWorkerClientServiceClientProtocol(t thrift.TTransport, iprot thrift.TProtocol, oprot thrift.TProtocol) *FileSystemWorkerClientServiceClient {
	return &FileSystemWorkerClientServiceClient{AlluxioServiceClient: common.NewAlluxioServiceClientProtocol(t, iprot, oprot)}
}

// Cancels a file which has not been completed in the under file system.
//
// Parameters:
//  - SessionId: the id of the current session
//  - TempUfsFileId: the worker specific file id of the ufs file
//  - Options: the options for canceling the file
func (p *FileSystemWorkerClientServiceClient) CancelUfsFile(sessionId int64, tempUfsFileId int64, options *CancelUfsFileTOptions) (err error) {
	if err = p.sendCancelUfsFile(sessionId, tempUfsFileId, options); err != nil {
		return
	}
	return p.recvCancelUfsFile()
}

func (p *FileSystemWorkerClientServiceClient) sendCancelUfsFile(sessionId int64, tempUfsFileId int64, options *CancelUfsFileTOptions) (err error) {
	oprot := p.OutputProtocol
	if oprot == nil {
		oprot = p.ProtocolFactory.GetProtocol(p.Transport)
		p.OutputProtocol = oprot
	}
	p.SeqId++
	if err = oprot.WriteMessageBegin("cancelUfsFile", thrift.CALL, p.SeqId); err != nil {
		return
	}
	args := FileSystemWorkerClientServiceCancelUfsFileArgs{
		SessionId:     sessionId,
		TempUfsFileId: tempUfsFileId,
		Options:       options,
	}
	if err = args.Write(oprot); err != nil {
		return
	}
	if err = oprot.WriteMessageEnd(); err != nil {
		return
	}
	return oprot.Flush()
}

func (p *FileSystemWorkerClientServiceClient) recvCancelUfsFile() (err error) {
	iprot := p.InputProtocol
	if iprot == nil {
		iprot = p.ProtocolFactory.GetProtocol(p.Transport)
		p.InputProtocol = iprot
	}
	method, mTypeId, seqId, err := iprot.ReadMessageBegin()
	if err != nil {
		return
	}
	if method != "cancelUfsFile" {
		err = thrift.NewTApplicationException(thrift.WRONG_METHOD_NAME, "cancelUfsFile failed: wrong method name")
		return
	}
	if p.SeqId != seqId {
		err = thrift.NewTApplicationException(thrift.BAD_SEQUENCE_ID, "cancelUfsFile failed: out of sequence response")
		return
	}
	if mTypeId == thrift.EXCEPTION {
		error0 := thrift.NewTApplicationException(thrift.UNKNOWN_APPLICATION_EXCEPTION, "Unknown Exception")
		var error1 error
		error1, err = error0.Read(iprot)
		if err != nil {
			return
		}
		if err = iprot.ReadMessageEnd(); err != nil {
			return
		}
		err = error1
		return
	}
	if mTypeId != thrift.REPLY {
		err = thrift.NewTApplicationException(thrift.INVALID_MESSAGE_TYPE_EXCEPTION, "cancelUfsFile failed: invalid message type")
		return
	}
	result := FileSystemWorkerClientServiceCancelUfsFileResult{}
	if err = result.Read(iprot); err != nil {
		return
	}
	if err = iprot.ReadMessageEnd(); err != nil {
		return
	}
	if result.E != nil {
		err = result.E
		return
	} else if result.Ioe != nil {
		err = result.Ioe
		return
	}
	return
}

// Closes a file in the under file system which was previously opened for reading.
//
//
// Parameters:
//  - SessionId: the id of the current session
//  - TempUfsFileId: the worker specific file id of the ufs file
//  - Options: the options for closing the file
func (p *FileSystemWorkerClientServiceClient) CloseUfsFile(sessionId int64, tempUfsFileId int64, options *CloseUfsFileTOptions) (err error) {
	if err = p.sendCloseUfsFile(sessionId, tempUfsFileId, options); err != nil {
		return
	}
	return p.recvCloseUfsFile()
}

func (p *FileSystemWorkerClientServiceClient) sendCloseUfsFile(sessionId int64, tempUfsFileId int64, options *CloseUfsFileTOptions) (err error) {
	oprot := p.OutputProtocol
	if oprot == nil {
		oprot = p.ProtocolFactory.GetProtocol(p.Transport)
		p.OutputProtocol = oprot
	}
	p.SeqId++
	if err = oprot.WriteMessageBegin("closeUfsFile", thrift.CALL, p.SeqId); err != nil {
		return
	}
	args := FileSystemWorkerClientServiceCloseUfsFileArgs{
		SessionId:     sessionId,
		TempUfsFileId: tempUfsFileId,
		Options:       options,
	}
	if err = args.Write(oprot); err != nil {
		return
	}
	if err = oprot.WriteMessageEnd(); err != nil {
		return
	}
	return oprot.Flush()
}

func (p *FileSystemWorkerClientServiceClient) recvCloseUfsFile() (err error) {
	iprot := p.InputProtocol
	if iprot == nil {
		iprot = p.ProtocolFactory.GetProtocol(p.Transport)
		p.InputProtocol = iprot
	}
	method, mTypeId, seqId, err := iprot.ReadMessageBegin()
	if err != nil {
		return
	}
	if method != "closeUfsFile" {
		err = thrift.NewTApplicationException(thrift.WRONG_METHOD_NAME, "closeUfsFile failed: wrong method name")
		return
	}
	if p.SeqId != seqId {
		err = thrift.NewTApplicationException(thrift.BAD_SEQUENCE_ID, "closeUfsFile failed: out of sequence response")
		return
	}
	if mTypeId == thrift.EXCEPTION {
		error2 := thrift.NewTApplicationException(thrift.UNKNOWN_APPLICATION_EXCEPTION, "Unknown Exception")
		var error3 error
		error3, err = error2.Read(iprot)
		if err != nil {
			return
		}
		if err = iprot.ReadMessageEnd(); err != nil {
			return
		}
		err = error3
		return
	}
	if mTypeId != thrift.REPLY {
		err = thrift.NewTApplicationException(thrift.INVALID_MESSAGE_TYPE_EXCEPTION, "closeUfsFile failed: invalid message type")
		return
	}
	result := FileSystemWorkerClientServiceCloseUfsFileResult{}
	if err = result.Read(iprot); err != nil {
		return
	}
	if err = iprot.ReadMessageEnd(); err != nil {
		return
	}
	if result.E != nil {
		err = result.E
		return
	} else if result.Ioe != nil {
		err = result.Ioe
		return
	}
	return
}

// Completes a file in the under file system.
//
// Parameters:
//  - SessionId: the id of the current session
//  - TempUfsFileId: the worker specific file id of the ufs file
//  - Options: the options for completing the file
func (p *FileSystemWorkerClientServiceClient) CompleteUfsFile(sessionId int64, tempUfsFileId int64, options *CompleteUfsFileTOptions) (r int64, err error) {
	if err = p.sendCompleteUfsFile(sessionId, tempUfsFileId, options); err != nil {
		return
	}
	return p.recvCompleteUfsFile()
}

func (p *FileSystemWorkerClientServiceClient) sendCompleteUfsFile(sessionId int64, tempUfsFileId int64, options *CompleteUfsFileTOptions) (err error) {
	oprot := p.OutputProtocol
	if oprot == nil {
		oprot = p.ProtocolFactory.GetProtocol(p.Transport)
		p.OutputProtocol = oprot
	}
	p.SeqId++
	if err = oprot.WriteMessageBegin("completeUfsFile", thrift.CALL, p.SeqId); err != nil {
		return
	}
	args := FileSystemWorkerClientServiceCompleteUfsFileArgs{
		SessionId:     sessionId,
		TempUfsFileId: tempUfsFileId,
		Options:       options,
	}
	if err = args.Write(oprot); err != nil {
		return
	}
	if err = oprot.WriteMessageEnd(); err != nil {
		return
	}
	return oprot.Flush()
}

func (p *FileSystemWorkerClientServiceClient) recvCompleteUfsFile() (value int64, err error) {
	iprot := p.InputProtocol
	if iprot == nil {
		iprot = p.ProtocolFactory.GetProtocol(p.Transport)
		p.InputProtocol = iprot
	}
	method, mTypeId, seqId, err := iprot.ReadMessageBegin()
	if err != nil {
		return
	}
	if method != "completeUfsFile" {
		err = thrift.NewTApplicationException(thrift.WRONG_METHOD_NAME, "completeUfsFile failed: wrong method name")
		return
	}
	if p.SeqId != seqId {
		err = thrift.NewTApplicationException(thrift.BAD_SEQUENCE_ID, "completeUfsFile failed: out of sequence response")
		return
	}
	if mTypeId == thrift.EXCEPTION {
		error4 := thrift.NewTApplicationException(thrift.UNKNOWN_APPLICATION_EXCEPTION, "Unknown Exception")
		var error5 error
		error5, err = error4.Read(iprot)
		if err != nil {
			return
		}
		if err = iprot.ReadMessageEnd(); err != nil {
			return
		}
		err = error5
		return
	}
	if mTypeId != thrift.REPLY {
		err = thrift.NewTApplicationException(thrift.INVALID_MESSAGE_TYPE_EXCEPTION, "completeUfsFile failed: invalid message type")
		return
	}
	result := FileSystemWorkerClientServiceCompleteUfsFileResult{}
	if err = result.Read(iprot); err != nil {
		return
	}
	if err = iprot.ReadMessageEnd(); err != nil {
		return
	}
	if result.E != nil {
		err = result.E
		return
	} else if result.Ioe != nil {
		err = result.Ioe
		return
	}
	value = result.GetSuccess()
	return
}

// Creates a file in the under file system.
//
// Parameters:
//  - SessionId: the id of the current session
//  - UfsPath: the path of the file in the ufs
//  - Options: the options for creating the file
func (p *FileSystemWorkerClientServiceClient) CreateUfsFile(sessionId int64, ufsPath string, options *CreateUfsFileTOptions) (r int64, err error) {
	if err = p.sendCreateUfsFile(sessionId, ufsPath, options); err != nil {
		return
	}
	return p.recvCreateUfsFile()
}

func (p *FileSystemWorkerClientServiceClient) sendCreateUfsFile(sessionId int64, ufsPath string, options *CreateUfsFileTOptions) (err error) {
	oprot := p.OutputProtocol
	if oprot == nil {
		oprot = p.ProtocolFactory.GetProtocol(p.Transport)
		p.OutputProtocol = oprot
	}
	p.SeqId++
	if err = oprot.WriteMessageBegin("createUfsFile", thrift.CALL, p.SeqId); err != nil {
		return
	}
	args := FileSystemWorkerClientServiceCreateUfsFileArgs{
		SessionId: sessionId,
		UfsPath:   ufsPath,
		Options:   options,
	}
	if err = args.Write(oprot); err != nil {
		return
	}
	if err = oprot.WriteMessageEnd(); err != nil {
		return
	}
	return oprot.Flush()
}

func (p *FileSystemWorkerClientServiceClient) recvCreateUfsFile() (value int64, err error) {
	iprot := p.InputProtocol
	if iprot == nil {
		iprot = p.ProtocolFactory.GetProtocol(p.Transport)
		p.InputProtocol = iprot
	}
	method, mTypeId, seqId, err := iprot.ReadMessageBegin()
	if err != nil {
		return
	}
	if method != "createUfsFile" {
		err = thrift.NewTApplicationException(thrift.WRONG_METHOD_NAME, "createUfsFile failed: wrong method name")
		return
	}
	if p.SeqId != seqId {
		err = thrift.NewTApplicationException(thrift.BAD_SEQUENCE_ID, "createUfsFile failed: out of sequence response")
		return
	}
	if mTypeId == thrift.EXCEPTION {
		error6 := thrift.NewTApplicationException(thrift.UNKNOWN_APPLICATION_EXCEPTION, "Unknown Exception")
		var error7 error
		error7, err = error6.Read(iprot)
		if err != nil {
			return
		}
		if err = iprot.ReadMessageEnd(); err != nil {
			return
		}
		err = error7
		return
	}
	if mTypeId != thrift.REPLY {
		err = thrift.NewTApplicationException(thrift.INVALID_MESSAGE_TYPE_EXCEPTION, "createUfsFile failed: invalid message type")
		return
	}
	result := FileSystemWorkerClientServiceCreateUfsFileResult{}
	if err = result.Read(iprot); err != nil {
		return
	}
	if err = iprot.ReadMessageEnd(); err != nil {
		return
	}
	if result.E != nil {
		err = result.E
		return
	} else if result.Ioe != nil {
		err = result.Ioe
		return
	}
	value = result.GetSuccess()
	return
}

// Opens an existing file in the under file system for reading.
//
// Parameters:
//  - SessionId: the id of the current session
//  - UfsPath: the path of the file in the ufs
//  - Options: the options for opening the file
func (p *FileSystemWorkerClientServiceClient) OpenUfsFile(sessionId int64, ufsPath string, options *OpenUfsFileTOptions) (r int64, err error) {
	if err = p.sendOpenUfsFile(sessionId, ufsPath, options); err != nil {
		return
	}
	return p.recvOpenUfsFile()
}

func (p *FileSystemWorkerClientServiceClient) sendOpenUfsFile(sessionId int64, ufsPath string, options *OpenUfsFileTOptions) (err error) {
	oprot := p.OutputProtocol
	if oprot == nil {
		oprot = p.ProtocolFactory.GetProtocol(p.Transport)
		p.OutputProtocol = oprot
	}
	p.SeqId++
	if err = oprot.WriteMessageBegin("openUfsFile", thrift.CALL, p.SeqId); err != nil {
		return
	}
	args := FileSystemWorkerClientServiceOpenUfsFileArgs{
		SessionId: sessionId,
		UfsPath:   ufsPath,
		Options:   options,
	}
	if err = args.Write(oprot); err != nil {
		return
	}
	if err = oprot.WriteMessageEnd(); err != nil {
		return
	}
	return oprot.Flush()
}

func (p *FileSystemWorkerClientServiceClient) recvOpenUfsFile() (value int64, err error) {
	iprot := p.InputProtocol
	if iprot == nil {
		iprot = p.ProtocolFactory.GetProtocol(p.Transport)
		p.InputProtocol = iprot
	}
	method, mTypeId, seqId, err := iprot.ReadMessageBegin()
	if err != nil {
		return
	}
	if method != "openUfsFile" {
		err = thrift.NewTApplicationException(thrift.WRONG_METHOD_NAME, "openUfsFile failed: wrong method name")
		return
	}
	if p.SeqId != seqId {
		err = thrift.NewTApplicationException(thrift.BAD_SEQUENCE_ID, "openUfsFile failed: out of sequence response")
		return
	}
	if mTypeId == thrift.EXCEPTION {
		error8 := thrift.NewTApplicationException(thrift.UNKNOWN_APPLICATION_EXCEPTION, "Unknown Exception")
		var error9 error
		error9, err = error8.Read(iprot)
		if err != nil {
			return
		}
		if err = iprot.ReadMessageEnd(); err != nil {
			return
		}
		err = error9
		return
	}
	if mTypeId != thrift.REPLY {
		err = thrift.NewTApplicationException(thrift.INVALID_MESSAGE_TYPE_EXCEPTION, "openUfsFile failed: invalid message type")
		return
	}
	result := FileSystemWorkerClientServiceOpenUfsFileResult{}
	if err = result.Read(iprot); err != nil {
		return
	}
	if err = iprot.ReadMessageEnd(); err != nil {
		return
	}
	if result.E != nil {
		err = result.E
		return
	} else if result.Ioe != nil {
		err = result.Ioe
		return
	}
	value = result.GetSuccess()
	return
}

// Local session send heartbeat to local worker to keep its state. It also can be used to send
// client metrics to the worker.
//
// Parameters:
//  - SessionId: the id of the current session
//  - Metrics: the client metrics
func (p *FileSystemWorkerClientServiceClient) SessionHeartbeat(sessionId int64, metrics []int64) (err error) {
	if err = p.sendSessionHeartbeat(sessionId, metrics); err != nil {
		return
	}
	return p.recvSessionHeartbeat()
}

func (p *FileSystemWorkerClientServiceClient) sendSessionHeartbeat(sessionId int64, metrics []int64) (err error) {
	oprot := p.OutputProtocol
	if oprot == nil {
		oprot = p.ProtocolFactory.GetProtocol(p.Transport)
		p.OutputProtocol = oprot
	}
	p.SeqId++
	if err = oprot.WriteMessageBegin("sessionHeartbeat", thrift.CALL, p.SeqId); err != nil {
		return
	}
	args := FileSystemWorkerClientServiceSessionHeartbeatArgs{
		SessionId: sessionId,
		Metrics:   metrics,
	}
	if err = args.Write(oprot); err != nil {
		return
	}
	if err = oprot.WriteMessageEnd(); err != nil {
		return
	}
	return oprot.Flush()
}

func (p *FileSystemWorkerClientServiceClient) recvSessionHeartbeat() (err error) {
	iprot := p.InputProtocol
	if iprot == nil {
		iprot = p.ProtocolFactory.GetProtocol(p.Transport)
		p.InputProtocol = iprot
	}
	method, mTypeId, seqId, err := iprot.ReadMessageBegin()
	if err != nil {
		return
	}
	if method != "sessionHeartbeat" {
		err = thrift.NewTApplicationException(thrift.WRONG_METHOD_NAME, "sessionHeartbeat failed: wrong method name")
		return
	}
	if p.SeqId != seqId {
		err = thrift.NewTApplicationException(thrift.BAD_SEQUENCE_ID, "sessionHeartbeat failed: out of sequence response")
		return
	}
	if mTypeId == thrift.EXCEPTION {
		error10 := thrift.NewTApplicationException(thrift.UNKNOWN_APPLICATION_EXCEPTION, "Unknown Exception")
		var error11 error
		error11, err = error10.Read(iprot)
		if err != nil {
			return
		}
		if err = iprot.ReadMessageEnd(); err != nil {
			return
		}
		err = error11
		return
	}
	if mTypeId != thrift.REPLY {
		err = thrift.NewTApplicationException(thrift.INVALID_MESSAGE_TYPE_EXCEPTION, "sessionHeartbeat failed: invalid message type")
		return
	}
	result := FileSystemWorkerClientServiceSessionHeartbeatResult{}
	if err = result.Read(iprot); err != nil {
		return
	}
	if err = iprot.ReadMessageEnd(); err != nil {
		return
	}
	return
}

type FileSystemWorkerClientServiceProcessor struct {
	*common.AlluxioServiceProcessor
}

func NewFileSystemWorkerClientServiceProcessor(handler FileSystemWorkerClientService) *FileSystemWorkerClientServiceProcessor {
	self12 := &FileSystemWorkerClientServiceProcessor{common.NewAlluxioServiceProcessor(handler)}
	self12.AddToProcessorMap("cancelUfsFile", &fileSystemWorkerClientServiceProcessorCancelUfsFile{handler: handler})
	self12.AddToProcessorMap("closeUfsFile", &fileSystemWorkerClientServiceProcessorCloseUfsFile{handler: handler})
	self12.AddToProcessorMap("completeUfsFile", &fileSystemWorkerClientServiceProcessorCompleteUfsFile{handler: handler})
	self12.AddToProcessorMap("createUfsFile", &fileSystemWorkerClientServiceProcessorCreateUfsFile{handler: handler})
	self12.AddToProcessorMap("openUfsFile", &fileSystemWorkerClientServiceProcessorOpenUfsFile{handler: handler})
	self12.AddToProcessorMap("sessionHeartbeat", &fileSystemWorkerClientServiceProcessorSessionHeartbeat{handler: handler})
	return self12
}

type fileSystemWorkerClientServiceProcessorCancelUfsFile struct {
	handler FileSystemWorkerClientService
}

func (p *fileSystemWorkerClientServiceProcessorCancelUfsFile) Process(seqId int32, iprot, oprot thrift.TProtocol) (success bool, err thrift.TException) {
	args := FileSystemWorkerClientServiceCancelUfsFileArgs{}
	if err = args.Read(iprot); err != nil {
		iprot.ReadMessageEnd()
		x := thrift.NewTApplicationException(thrift.PROTOCOL_ERROR, err.Error())
		oprot.WriteMessageBegin("cancelUfsFile", thrift.EXCEPTION, seqId)
		x.Write(oprot)
		oprot.WriteMessageEnd()
		oprot.Flush()
		return false, err
	}

	iprot.ReadMessageEnd()
	result := FileSystemWorkerClientServiceCancelUfsFileResult{}
	var err2 error
	if err2 = p.handler.CancelUfsFile(args.SessionId, args.TempUfsFileId, args.Options); err2 != nil {
		switch v := err2.(type) {
		case *exception.AlluxioTException:
			result.E = v
		case *exception.ThriftIOException:
			result.Ioe = v
		default:
			x := thrift.NewTApplicationException(thrift.INTERNAL_ERROR, "Internal error processing cancelUfsFile: "+err2.Error())
			oprot.WriteMessageBegin("cancelUfsFile", thrift.EXCEPTION, seqId)
			x.Write(oprot)
			oprot.WriteMessageEnd()
			oprot.Flush()
			return true, err2
		}
	}
	if err2 = oprot.WriteMessageBegin("cancelUfsFile", thrift.REPLY, seqId); err2 != nil {
		err = err2
	}
	if err2 = result.Write(oprot); err == nil && err2 != nil {
		err = err2
	}
	if err2 = oprot.WriteMessageEnd(); err == nil && err2 != nil {
		err = err2
	}
	if err2 = oprot.Flush(); err == nil && err2 != nil {
		err = err2
	}
	if err != nil {
		return
	}
	return true, err
}

type fileSystemWorkerClientServiceProcessorCloseUfsFile struct {
	handler FileSystemWorkerClientService
}

func (p *fileSystemWorkerClientServiceProcessorCloseUfsFile) Process(seqId int32, iprot, oprot thrift.TProtocol) (success bool, err thrift.TException) {
	args := FileSystemWorkerClientServiceCloseUfsFileArgs{}
	if err = args.Read(iprot); err != nil {
		iprot.ReadMessageEnd()
		x := thrift.NewTApplicationException(thrift.PROTOCOL_ERROR, err.Error())
		oprot.WriteMessageBegin("closeUfsFile", thrift.EXCEPTION, seqId)
		x.Write(oprot)
		oprot.WriteMessageEnd()
		oprot.Flush()
		return false, err
	}

	iprot.ReadMessageEnd()
	result := FileSystemWorkerClientServiceCloseUfsFileResult{}
	var err2 error
	if err2 = p.handler.CloseUfsFile(args.SessionId, args.TempUfsFileId, args.Options); err2 != nil {
		switch v := err2.(type) {
		case *exception.AlluxioTException:
			result.E = v
		case *exception.ThriftIOException:
			result.Ioe = v
		default:
			x := thrift.NewTApplicationException(thrift.INTERNAL_ERROR, "Internal error processing closeUfsFile: "+err2.Error())
			oprot.WriteMessageBegin("closeUfsFile", thrift.EXCEPTION, seqId)
			x.Write(oprot)
			oprot.WriteMessageEnd()
			oprot.Flush()
			return true, err2
		}
	}
	if err2 = oprot.WriteMessageBegin("closeUfsFile", thrift.REPLY, seqId); err2 != nil {
		err = err2
	}
	if err2 = result.Write(oprot); err == nil && err2 != nil {
		err = err2
	}
	if err2 = oprot.WriteMessageEnd(); err == nil && err2 != nil {
		err = err2
	}
	if err2 = oprot.Flush(); err == nil && err2 != nil {
		err = err2
	}
	if err != nil {
		return
	}
	return true, err
}

type fileSystemWorkerClientServiceProcessorCompleteUfsFile struct {
	handler FileSystemWorkerClientService
}

func (p *fileSystemWorkerClientServiceProcessorCompleteUfsFile) Process(seqId int32, iprot, oprot thrift.TProtocol) (success bool, err thrift.TException) {
	args := FileSystemWorkerClientServiceCompleteUfsFileArgs{}
	if err = args.Read(iprot); err != nil {
		iprot.ReadMessageEnd()
		x := thrift.NewTApplicationException(thrift.PROTOCOL_ERROR, err.Error())
		oprot.WriteMessageBegin("completeUfsFile", thrift.EXCEPTION, seqId)
		x.Write(oprot)
		oprot.WriteMessageEnd()
		oprot.Flush()
		return false, err
	}

	iprot.ReadMessageEnd()
	result := FileSystemWorkerClientServiceCompleteUfsFileResult{}
	var retval int64
	var err2 error
	if retval, err2 = p.handler.CompleteUfsFile(args.SessionId, args.TempUfsFileId, args.Options); err2 != nil {
		switch v := err2.(type) {
		case *exception.AlluxioTException:
			result.E = v
		case *exception.ThriftIOException:
			result.Ioe = v
		default:
			x := thrift.NewTApplicationException(thrift.INTERNAL_ERROR, "Internal error processing completeUfsFile: "+err2.Error())
			oprot.WriteMessageBegin("completeUfsFile", thrift.EXCEPTION, seqId)
			x.Write(oprot)
			oprot.WriteMessageEnd()
			oprot.Flush()
			return true, err2
		}
	} else {
		result.Success = &retval
	}
	if err2 = oprot.WriteMessageBegin("completeUfsFile", thrift.REPLY, seqId); err2 != nil {
		err = err2
	}
	if err2 = result.Write(oprot); err == nil && err2 != nil {
		err = err2
	}
	if err2 = oprot.WriteMessageEnd(); err == nil && err2 != nil {
		err = err2
	}
	if err2 = oprot.Flush(); err == nil && err2 != nil {
		err = err2
	}
	if err != nil {
		return
	}
	return true, err
}

type fileSystemWorkerClientServiceProcessorCreateUfsFile struct {
	handler FileSystemWorkerClientService
}

func (p *fileSystemWorkerClientServiceProcessorCreateUfsFile) Process(seqId int32, iprot, oprot thrift.TProtocol) (success bool, err thrift.TException) {
	args := FileSystemWorkerClientServiceCreateUfsFileArgs{}
	if err = args.Read(iprot); err != nil {
		iprot.ReadMessageEnd()
		x := thrift.NewTApplicationException(thrift.PROTOCOL_ERROR, err.Error())
		oprot.WriteMessageBegin("createUfsFile", thrift.EXCEPTION, seqId)
		x.Write(oprot)
		oprot.WriteMessageEnd()
		oprot.Flush()
		return false, err
	}

	iprot.ReadMessageEnd()
	result := FileSystemWorkerClientServiceCreateUfsFileResult{}
	var retval int64
	var err2 error
	if retval, err2 = p.handler.CreateUfsFile(args.SessionId, args.UfsPath, args.Options); err2 != nil {
		switch v := err2.(type) {
		case *exception.AlluxioTException:
			result.E = v
		case *exception.ThriftIOException:
			result.Ioe = v
		default:
			x := thrift.NewTApplicationException(thrift.INTERNAL_ERROR, "Internal error processing createUfsFile: "+err2.Error())
			oprot.WriteMessageBegin("createUfsFile", thrift.EXCEPTION, seqId)
			x.Write(oprot)
			oprot.WriteMessageEnd()
			oprot.Flush()
			return true, err2
		}
	} else {
		result.Success = &retval
	}
	if err2 = oprot.WriteMessageBegin("createUfsFile", thrift.REPLY, seqId); err2 != nil {
		err = err2
	}
	if err2 = result.Write(oprot); err == nil && err2 != nil {
		err = err2
	}
	if err2 = oprot.WriteMessageEnd(); err == nil && err2 != nil {
		err = err2
	}
	if err2 = oprot.Flush(); err == nil && err2 != nil {
		err = err2
	}
	if err != nil {
		return
	}
	return true, err
}

type fileSystemWorkerClientServiceProcessorOpenUfsFile struct {
	handler FileSystemWorkerClientService
}

func (p *fileSystemWorkerClientServiceProcessorOpenUfsFile) Process(seqId int32, iprot, oprot thrift.TProtocol) (success bool, err thrift.TException) {
	args := FileSystemWorkerClientServiceOpenUfsFileArgs{}
	if err = args.Read(iprot); err != nil {
		iprot.ReadMessageEnd()
		x := thrift.NewTApplicationException(thrift.PROTOCOL_ERROR, err.Error())
		oprot.WriteMessageBegin("openUfsFile", thrift.EXCEPTION, seqId)
		x.Write(oprot)
		oprot.WriteMessageEnd()
		oprot.Flush()
		return false, err
	}

	iprot.ReadMessageEnd()
	result := FileSystemWorkerClientServiceOpenUfsFileResult{}
	var retval int64
	var err2 error
	if retval, err2 = p.handler.OpenUfsFile(args.SessionId, args.UfsPath, args.Options); err2 != nil {
		switch v := err2.(type) {
		case *exception.AlluxioTException:
			result.E = v
		case *exception.ThriftIOException:
			result.Ioe = v
		default:
			x := thrift.NewTApplicationException(thrift.INTERNAL_ERROR, "Internal error processing openUfsFile: "+err2.Error())
			oprot.WriteMessageBegin("openUfsFile", thrift.EXCEPTION, seqId)
			x.Write(oprot)
			oprot.WriteMessageEnd()
			oprot.Flush()
			return true, err2
		}
	} else {
		result.Success = &retval
	}
	if err2 = oprot.WriteMessageBegin("openUfsFile", thrift.REPLY, seqId); err2 != nil {
		err = err2
	}
	if err2 = result.Write(oprot); err == nil && err2 != nil {
		err = err2
	}
	if err2 = oprot.WriteMessageEnd(); err == nil && err2 != nil {
		err = err2
	}
	if err2 = oprot.Flush(); err == nil && err2 != nil {
		err = err2
	}
	if err != nil {
		return
	}
	return true, err
}

type fileSystemWorkerClientServiceProcessorSessionHeartbeat struct {
	handler FileSystemWorkerClientService
}

func (p *fileSystemWorkerClientServiceProcessorSessionHeartbeat) Process(seqId int32, iprot, oprot thrift.TProtocol) (success bool, err thrift.TException) {
	args := FileSystemWorkerClientServiceSessionHeartbeatArgs{}
	if err = args.Read(iprot); err != nil {
		iprot.ReadMessageEnd()
		x := thrift.NewTApplicationException(thrift.PROTOCOL_ERROR, err.Error())
		oprot.WriteMessageBegin("sessionHeartbeat", thrift.EXCEPTION, seqId)
		x.Write(oprot)
		oprot.WriteMessageEnd()
		oprot.Flush()
		return false, err
	}

	iprot.ReadMessageEnd()
	result := FileSystemWorkerClientServiceSessionHeartbeatResult{}
	var err2 error
	if err2 = p.handler.SessionHeartbeat(args.SessionId, args.Metrics); err2 != nil {
		x := thrift.NewTApplicationException(thrift.INTERNAL_ERROR, "Internal error processing sessionHeartbeat: "+err2.Error())
		oprot.WriteMessageBegin("sessionHeartbeat", thrift.EXCEPTION, seqId)
		x.Write(oprot)
		oprot.WriteMessageEnd()
		oprot.Flush()
		return true, err2
	}
	if err2 = oprot.WriteMessageBegin("sessionHeartbeat", thrift.REPLY, seqId); err2 != nil {
		err = err2
	}
	if err2 = result.Write(oprot); err == nil && err2 != nil {
		err = err2
	}
	if err2 = oprot.WriteMessageEnd(); err == nil && err2 != nil {
		err = err2
	}
	if err2 = oprot.Flush(); err == nil && err2 != nil {
		err = err2
	}
	if err != nil {
		return
	}
	return true, err
}

// HELPER FUNCTIONS AND STRUCTURES

// Attributes:
//  - SessionId: the id of the current session
//  - TempUfsFileId: the worker specific file id of the ufs file
//  - Options: the options for canceling the file
type FileSystemWorkerClientServiceCancelUfsFileArgs struct {
	SessionId     int64                  `thrift:"sessionId,1" json:"sessionId"`
	TempUfsFileId int64                  `thrift:"tempUfsFileId,2" json:"tempUfsFileId"`
	Options       *CancelUfsFileTOptions `thrift:"options,3" json:"options"`
}

func NewFileSystemWorkerClientServiceCancelUfsFileArgs() *FileSystemWorkerClientServiceCancelUfsFileArgs {
	return &FileSystemWorkerClientServiceCancelUfsFileArgs{}
}

func (p *FileSystemWorkerClientServiceCancelUfsFileArgs) GetSessionId() int64 {
	return p.SessionId
}

func (p *FileSystemWorkerClientServiceCancelUfsFileArgs) GetTempUfsFileId() int64 {
	return p.TempUfsFileId
}

var FileSystemWorkerClientServiceCancelUfsFileArgs_Options_DEFAULT *CancelUfsFileTOptions

func (p *FileSystemWorkerClientServiceCancelUfsFileArgs) GetOptions() *CancelUfsFileTOptions {
	if !p.IsSetOptions() {
		return FileSystemWorkerClientServiceCancelUfsFileArgs_Options_DEFAULT
	}
	return p.Options
}
func (p *FileSystemWorkerClientServiceCancelUfsFileArgs) IsSetOptions() bool {
	return p.Options != nil
}

func (p *FileSystemWorkerClientServiceCancelUfsFileArgs) Read(iprot thrift.TProtocol) error {
	if _, err := iprot.ReadStructBegin(); err != nil {
		return thrift.PrependError(fmt.Sprintf("%T read error: ", p), err)
	}

	for {
		_, fieldTypeId, fieldId, err := iprot.ReadFieldBegin()
		if err != nil {
			return thrift.PrependError(fmt.Sprintf("%T field %d read error: ", p, fieldId), err)
		}
		if fieldTypeId == thrift.STOP {
			break
		}
		switch fieldId {
		case 1:
			if err := p.readField1(iprot); err != nil {
				return err
			}
		case 2:
			if err := p.readField2(iprot); err != nil {
				return err
			}
		case 3:
			if err := p.readField3(iprot); err != nil {
				return err
			}
		default:
			if err := iprot.Skip(fieldTypeId); err != nil {
				return err
			}
		}
		if err := iprot.ReadFieldEnd(); err != nil {
			return err
		}
	}
	if err := iprot.ReadStructEnd(); err != nil {
		return thrift.PrependError(fmt.Sprintf("%T read struct end error: ", p), err)
	}
	return nil
}

func (p *FileSystemWorkerClientServiceCancelUfsFileArgs) readField1(iprot thrift.TProtocol) error {
	if v, err := iprot.ReadI64(); err != nil {
		return thrift.PrependError("error reading field 1: ", err)
	} else {
		p.SessionId = v
	}
	return nil
}

func (p *FileSystemWorkerClientServiceCancelUfsFileArgs) readField2(iprot thrift.TProtocol) error {
	if v, err := iprot.ReadI64(); err != nil {
		return thrift.PrependError("error reading field 2: ", err)
	} else {
		p.TempUfsFileId = v
	}
	return nil
}

func (p *FileSystemWorkerClientServiceCancelUfsFileArgs) readField3(iprot thrift.TProtocol) error {
	p.Options = &CancelUfsFileTOptions{}
	if err := p.Options.Read(iprot); err != nil {
		return thrift.PrependError(fmt.Sprintf("%T error reading struct: ", p.Options), err)
	}
	return nil
}

func (p *FileSystemWorkerClientServiceCancelUfsFileArgs) Write(oprot thrift.TProtocol) error {
	if err := oprot.WriteStructBegin("cancelUfsFile_args"); err != nil {
		return thrift.PrependError(fmt.Sprintf("%T write struct begin error: ", p), err)
	}
	if err := p.writeField1(oprot); err != nil {
		return err
	}
	if err := p.writeField2(oprot); err != nil {
		return err
	}
	if err := p.writeField3(oprot); err != nil {
		return err
	}
	if err := oprot.WriteFieldStop(); err != nil {
		return thrift.PrependError("write field stop error: ", err)
	}
	if err := oprot.WriteStructEnd(); err != nil {
		return thrift.PrependError("write struct stop error: ", err)
	}
	return nil
}

func (p *FileSystemWorkerClientServiceCancelUfsFileArgs) writeField1(oprot thrift.TProtocol) (err error) {
	if err := oprot.WriteFieldBegin("sessionId", thrift.I64, 1); err != nil {
		return thrift.PrependError(fmt.Sprintf("%T write field begin error 1:sessionId: ", p), err)
	}
	if err := oprot.WriteI64(int64(p.SessionId)); err != nil {
		return thrift.PrependError(fmt.Sprintf("%T.sessionId (1) field write error: ", p), err)
	}
	if err := oprot.WriteFieldEnd(); err != nil {
		return thrift.PrependError(fmt.Sprintf("%T write field end error 1:sessionId: ", p), err)
	}
	return err
}

func (p *FileSystemWorkerClientServiceCancelUfsFileArgs) writeField2(oprot thrift.TProtocol) (err error) {
	if err := oprot.WriteFieldBegin("tempUfsFileId", thrift.I64, 2); err != nil {
		return thrift.PrependError(fmt.Sprintf("%T write field begin error 2:tempUfsFileId: ", p), err)
	}
	if err := oprot.WriteI64(int64(p.TempUfsFileId)); err != nil {
		return thrift.PrependError(fmt.Sprintf("%T.tempUfsFileId (2) field write error: ", p), err)
	}
	if err := oprot.WriteFieldEnd(); err != nil {
		return thrift.PrependError(fmt.Sprintf("%T write field end error 2:tempUfsFileId: ", p), err)
	}
	return err
}

func (p *FileSystemWorkerClientServiceCancelUfsFileArgs) writeField3(oprot thrift.TProtocol) (err error) {
	if err := oprot.WriteFieldBegin("options", thrift.STRUCT, 3); err != nil {
		return thrift.PrependError(fmt.Sprintf("%T write field begin error 3:options: ", p), err)
	}
	if err := p.Options.Write(oprot); err != nil {
		return thrift.PrependError(fmt.Sprintf("%T error writing struct: ", p.Options), err)
	}
	if err := oprot.WriteFieldEnd(); err != nil {
		return thrift.PrependError(fmt.Sprintf("%T write field end error 3:options: ", p), err)
	}
	return err
}

func (p *FileSystemWorkerClientServiceCancelUfsFileArgs) String() string {
	if p == nil {
		return "<nil>"
	}
	return fmt.Sprintf("FileSystemWorkerClientServiceCancelUfsFileArgs(%+v)", *p)
}

// Attributes:
//  - E
//  - Ioe
type FileSystemWorkerClientServiceCancelUfsFileResult struct {
	E   *exception.AlluxioTException `thrift:"e,1" json:"e,omitempty"`
	Ioe *exception.ThriftIOException `thrift:"ioe,2" json:"ioe,omitempty"`
}

func NewFileSystemWorkerClientServiceCancelUfsFileResult() *FileSystemWorkerClientServiceCancelUfsFileResult {
	return &FileSystemWorkerClientServiceCancelUfsFileResult{}
}

var FileSystemWorkerClientServiceCancelUfsFileResult_E_DEFAULT *exception.AlluxioTException

func (p *FileSystemWorkerClientServiceCancelUfsFileResult) GetE() *exception.AlluxioTException {
	if !p.IsSetE() {
		return FileSystemWorkerClientServiceCancelUfsFileResult_E_DEFAULT
	}
	return p.E
}

var FileSystemWorkerClientServiceCancelUfsFileResult_Ioe_DEFAULT *exception.ThriftIOException

func (p *FileSystemWorkerClientServiceCancelUfsFileResult) GetIoe() *exception.ThriftIOException {
	if !p.IsSetIoe() {
		return FileSystemWorkerClientServiceCancelUfsFileResult_Ioe_DEFAULT
	}
	return p.Ioe
}
func (p *FileSystemWorkerClientServiceCancelUfsFileResult) IsSetE() bool {
	return p.E != nil
}

func (p *FileSystemWorkerClientServiceCancelUfsFileResult) IsSetIoe() bool {
	return p.Ioe != nil
}

func (p *FileSystemWorkerClientServiceCancelUfsFileResult) Read(iprot thrift.TProtocol) error {
	if _, err := iprot.ReadStructBegin(); err != nil {
		return thrift.PrependError(fmt.Sprintf("%T read error: ", p), err)
	}

	for {
		_, fieldTypeId, fieldId, err := iprot.ReadFieldBegin()
		if err != nil {
			return thrift.PrependError(fmt.Sprintf("%T field %d read error: ", p, fieldId), err)
		}
		if fieldTypeId == thrift.STOP {
			break
		}
		switch fieldId {
		case 1:
			if err := p.readField1(iprot); err != nil {
				return err
			}
		case 2:
			if err := p.readField2(iprot); err != nil {
				return err
			}
		default:
			if err := iprot.Skip(fieldTypeId); err != nil {
				return err
			}
		}
		if err := iprot.ReadFieldEnd(); err != nil {
			return err
		}
	}
	if err := iprot.ReadStructEnd(); err != nil {
		return thrift.PrependError(fmt.Sprintf("%T read struct end error: ", p), err)
	}
	return nil
}

func (p *FileSystemWorkerClientServiceCancelUfsFileResult) readField1(iprot thrift.TProtocol) error {
	p.E = &exception.AlluxioTException{}
	if err := p.E.Read(iprot); err != nil {
		return thrift.PrependError(fmt.Sprintf("%T error reading struct: ", p.E), err)
	}
	return nil
}

func (p *FileSystemWorkerClientServiceCancelUfsFileResult) readField2(iprot thrift.TProtocol) error {
	p.Ioe = &exception.ThriftIOException{}
	if err := p.Ioe.Read(iprot); err != nil {
		return thrift.PrependError(fmt.Sprintf("%T error reading struct: ", p.Ioe), err)
	}
	return nil
}

func (p *FileSystemWorkerClientServiceCancelUfsFileResult) Write(oprot thrift.TProtocol) error {
	if err := oprot.WriteStructBegin("cancelUfsFile_result"); err != nil {
		return thrift.PrependError(fmt.Sprintf("%T write struct begin error: ", p), err)
	}
	if err := p.writeField1(oprot); err != nil {
		return err
	}
	if err := p.writeField2(oprot); err != nil {
		return err
	}
	if err := oprot.WriteFieldStop(); err != nil {
		return thrift.PrependError("write field stop error: ", err)
	}
	if err := oprot.WriteStructEnd(); err != nil {
		return thrift.PrependError("write struct stop error: ", err)
	}
	return nil
}

func (p *FileSystemWorkerClientServiceCancelUfsFileResult) writeField1(oprot thrift.TProtocol) (err error) {
	if p.IsSetE() {
		if err := oprot.WriteFieldBegin("e", thrift.STRUCT, 1); err != nil {
			return thrift.PrependError(fmt.Sprintf("%T write field begin error 1:e: ", p), err)
		}
		if err := p.E.Write(oprot); err != nil {
			return thrift.PrependError(fmt.Sprintf("%T error writing struct: ", p.E), err)
		}
		if err := oprot.WriteFieldEnd(); err != nil {
			return thrift.PrependError(fmt.Sprintf("%T write field end error 1:e: ", p), err)
		}
	}
	return err
}

func (p *FileSystemWorkerClientServiceCancelUfsFileResult) writeField2(oprot thrift.TProtocol) (err error) {
	if p.IsSetIoe() {
		if err := oprot.WriteFieldBegin("ioe", thrift.STRUCT, 2); err != nil {
			return thrift.PrependError(fmt.Sprintf("%T write field begin error 2:ioe: ", p), err)
		}
		if err := p.Ioe.Write(oprot); err != nil {
			return thrift.PrependError(fmt.Sprintf("%T error writing struct: ", p.Ioe), err)
		}
		if err := oprot.WriteFieldEnd(); err != nil {
			return thrift.PrependError(fmt.Sprintf("%T write field end error 2:ioe: ", p), err)
		}
	}
	return err
}

func (p *FileSystemWorkerClientServiceCancelUfsFileResult) String() string {
	if p == nil {
		return "<nil>"
	}
	return fmt.Sprintf("FileSystemWorkerClientServiceCancelUfsFileResult(%+v)", *p)
}

// Attributes:
//  - SessionId: the id of the current session
//  - TempUfsFileId: the worker specific file id of the ufs file
//  - Options: the options for closing the file
type FileSystemWorkerClientServiceCloseUfsFileArgs struct {
	SessionId     int64                 `thrift:"sessionId,1" json:"sessionId"`
	TempUfsFileId int64                 `thrift:"tempUfsFileId,2" json:"tempUfsFileId"`
	Options       *CloseUfsFileTOptions `thrift:"options,3" json:"options"`
}

func NewFileSystemWorkerClientServiceCloseUfsFileArgs() *FileSystemWorkerClientServiceCloseUfsFileArgs {
	return &FileSystemWorkerClientServiceCloseUfsFileArgs{}
}

func (p *FileSystemWorkerClientServiceCloseUfsFileArgs) GetSessionId() int64 {
	return p.SessionId
}

func (p *FileSystemWorkerClientServiceCloseUfsFileArgs) GetTempUfsFileId() int64 {
	return p.TempUfsFileId
}

var FileSystemWorkerClientServiceCloseUfsFileArgs_Options_DEFAULT *CloseUfsFileTOptions

func (p *FileSystemWorkerClientServiceCloseUfsFileArgs) GetOptions() *CloseUfsFileTOptions {
	if !p.IsSetOptions() {
		return FileSystemWorkerClientServiceCloseUfsFileArgs_Options_DEFAULT
	}
	return p.Options
}
func (p *FileSystemWorkerClientServiceCloseUfsFileArgs) IsSetOptions() bool {
	return p.Options != nil
}

func (p *FileSystemWorkerClientServiceCloseUfsFileArgs) Read(iprot thrift.TProtocol) error {
	if _, err := iprot.ReadStructBegin(); err != nil {
		return thrift.PrependError(fmt.Sprintf("%T read error: ", p), err)
	}

	for {
		_, fieldTypeId, fieldId, err := iprot.ReadFieldBegin()
		if err != nil {
			return thrift.PrependError(fmt.Sprintf("%T field %d read error: ", p, fieldId), err)
		}
		if fieldTypeId == thrift.STOP {
			break
		}
		switch fieldId {
		case 1:
			if err := p.readField1(iprot); err != nil {
				return err
			}
		case 2:
			if err := p.readField2(iprot); err != nil {
				return err
			}
		case 3:
			if err := p.readField3(iprot); err != nil {
				return err
			}
		default:
			if err := iprot.Skip(fieldTypeId); err != nil {
				return err
			}
		}
		if err := iprot.ReadFieldEnd(); err != nil {
			return err
		}
	}
	if err := iprot.ReadStructEnd(); err != nil {
		return thrift.PrependError(fmt.Sprintf("%T read struct end error: ", p), err)
	}
	return nil
}

func (p *FileSystemWorkerClientServiceCloseUfsFileArgs) readField1(iprot thrift.TProtocol) error {
	if v, err := iprot.ReadI64(); err != nil {
		return thrift.PrependError("error reading field 1: ", err)
	} else {
		p.SessionId = v
	}
	return nil
}

func (p *FileSystemWorkerClientServiceCloseUfsFileArgs) readField2(iprot thrift.TProtocol) error {
	if v, err := iprot.ReadI64(); err != nil {
		return thrift.PrependError("error reading field 2: ", err)
	} else {
		p.TempUfsFileId = v
	}
	return nil
}

func (p *FileSystemWorkerClientServiceCloseUfsFileArgs) readField3(iprot thrift.TProtocol) error {
	p.Options = &CloseUfsFileTOptions{}
	if err := p.Options.Read(iprot); err != nil {
		return thrift.PrependError(fmt.Sprintf("%T error reading struct: ", p.Options), err)
	}
	return nil
}

func (p *FileSystemWorkerClientServiceCloseUfsFileArgs) Write(oprot thrift.TProtocol) error {
	if err := oprot.WriteStructBegin("closeUfsFile_args"); err != nil {
		return thrift.PrependError(fmt.Sprintf("%T write struct begin error: ", p), err)
	}
	if err := p.writeField1(oprot); err != nil {
		return err
	}
	if err := p.writeField2(oprot); err != nil {
		return err
	}
	if err := p.writeField3(oprot); err != nil {
		return err
	}
	if err := oprot.WriteFieldStop(); err != nil {
		return thrift.PrependError("write field stop error: ", err)
	}
	if err := oprot.WriteStructEnd(); err != nil {
		return thrift.PrependError("write struct stop error: ", err)
	}
	return nil
}

func (p *FileSystemWorkerClientServiceCloseUfsFileArgs) writeField1(oprot thrift.TProtocol) (err error) {
	if err := oprot.WriteFieldBegin("sessionId", thrift.I64, 1); err != nil {
		return thrift.PrependError(fmt.Sprintf("%T write field begin error 1:sessionId: ", p), err)
	}
	if err := oprot.WriteI64(int64(p.SessionId)); err != nil {
		return thrift.PrependError(fmt.Sprintf("%T.sessionId (1) field write error: ", p), err)
	}
	if err := oprot.WriteFieldEnd(); err != nil {
		return thrift.PrependError(fmt.Sprintf("%T write field end error 1:sessionId: ", p), err)
	}
	return err
}

func (p *FileSystemWorkerClientServiceCloseUfsFileArgs) writeField2(oprot thrift.TProtocol) (err error) {
	if err := oprot.WriteFieldBegin("tempUfsFileId", thrift.I64, 2); err != nil {
		return thrift.PrependError(fmt.Sprintf("%T write field begin error 2:tempUfsFileId: ", p), err)
	}
	if err := oprot.WriteI64(int64(p.TempUfsFileId)); err != nil {
		return thrift.PrependError(fmt.Sprintf("%T.tempUfsFileId (2) field write error: ", p), err)
	}
	if err := oprot.WriteFieldEnd(); err != nil {
		return thrift.PrependError(fmt.Sprintf("%T write field end error 2:tempUfsFileId: ", p), err)
	}
	return err
}

func (p *FileSystemWorkerClientServiceCloseUfsFileArgs) writeField3(oprot thrift.TProtocol) (err error) {
	if err := oprot.WriteFieldBegin("options", thrift.STRUCT, 3); err != nil {
		return thrift.PrependError(fmt.Sprintf("%T write field begin error 3:options: ", p), err)
	}
	if err := p.Options.Write(oprot); err != nil {
		return thrift.PrependError(fmt.Sprintf("%T error writing struct: ", p.Options), err)
	}
	if err := oprot.WriteFieldEnd(); err != nil {
		return thrift.PrependError(fmt.Sprintf("%T write field end error 3:options: ", p), err)
	}
	return err
}

func (p *FileSystemWorkerClientServiceCloseUfsFileArgs) String() string {
	if p == nil {
		return "<nil>"
	}
	return fmt.Sprintf("FileSystemWorkerClientServiceCloseUfsFileArgs(%+v)", *p)
}

// Attributes:
//  - E
//  - Ioe
type FileSystemWorkerClientServiceCloseUfsFileResult struct {
	E   *exception.AlluxioTException `thrift:"e,1" json:"e,omitempty"`
	Ioe *exception.ThriftIOException `thrift:"ioe,2" json:"ioe,omitempty"`
}

func NewFileSystemWorkerClientServiceCloseUfsFileResult() *FileSystemWorkerClientServiceCloseUfsFileResult {
	return &FileSystemWorkerClientServiceCloseUfsFileResult{}
}

var FileSystemWorkerClientServiceCloseUfsFileResult_E_DEFAULT *exception.AlluxioTException

func (p *FileSystemWorkerClientServiceCloseUfsFileResult) GetE() *exception.AlluxioTException {
	if !p.IsSetE() {
		return FileSystemWorkerClientServiceCloseUfsFileResult_E_DEFAULT
	}
	return p.E
}

var FileSystemWorkerClientServiceCloseUfsFileResult_Ioe_DEFAULT *exception.ThriftIOException

func (p *FileSystemWorkerClientServiceCloseUfsFileResult) GetIoe() *exception.ThriftIOException {
	if !p.IsSetIoe() {
		return FileSystemWorkerClientServiceCloseUfsFileResult_Ioe_DEFAULT
	}
	return p.Ioe
}
func (p *FileSystemWorkerClientServiceCloseUfsFileResult) IsSetE() bool {
	return p.E != nil
}

func (p *FileSystemWorkerClientServiceCloseUfsFileResult) IsSetIoe() bool {
	return p.Ioe != nil
}

func (p *FileSystemWorkerClientServiceCloseUfsFileResult) Read(iprot thrift.TProtocol) error {
	if _, err := iprot.ReadStructBegin(); err != nil {
		return thrift.PrependError(fmt.Sprintf("%T read error: ", p), err)
	}

	for {
		_, fieldTypeId, fieldId, err := iprot.ReadFieldBegin()
		if err != nil {
			return thrift.PrependError(fmt.Sprintf("%T field %d read error: ", p, fieldId), err)
		}
		if fieldTypeId == thrift.STOP {
			break
		}
		switch fieldId {
		case 1:
			if err := p.readField1(iprot); err != nil {
				return err
			}
		case 2:
			if err := p.readField2(iprot); err != nil {
				return err
			}
		default:
			if err := iprot.Skip(fieldTypeId); err != nil {
				return err
			}
		}
		if err := iprot.ReadFieldEnd(); err != nil {
			return err
		}
	}
	if err := iprot.ReadStructEnd(); err != nil {
		return thrift.PrependError(fmt.Sprintf("%T read struct end error: ", p), err)
	}
	return nil
}

func (p *FileSystemWorkerClientServiceCloseUfsFileResult) readField1(iprot thrift.TProtocol) error {
	p.E = &exception.AlluxioTException{}
	if err := p.E.Read(iprot); err != nil {
		return thrift.PrependError(fmt.Sprintf("%T error reading struct: ", p.E), err)
	}
	return nil
}

func (p *FileSystemWorkerClientServiceCloseUfsFileResult) readField2(iprot thrift.TProtocol) error {
	p.Ioe = &exception.ThriftIOException{}
	if err := p.Ioe.Read(iprot); err != nil {
		return thrift.PrependError(fmt.Sprintf("%T error reading struct: ", p.Ioe), err)
	}
	return nil
}

func (p *FileSystemWorkerClientServiceCloseUfsFileResult) Write(oprot thrift.TProtocol) error {
	if err := oprot.WriteStructBegin("closeUfsFile_result"); err != nil {
		return thrift.PrependError(fmt.Sprintf("%T write struct begin error: ", p), err)
	}
	if err := p.writeField1(oprot); err != nil {
		return err
	}
	if err := p.writeField2(oprot); err != nil {
		return err
	}
	if err := oprot.WriteFieldStop(); err != nil {
		return thrift.PrependError("write field stop error: ", err)
	}
	if err := oprot.WriteStructEnd(); err != nil {
		return thrift.PrependError("write struct stop error: ", err)
	}
	return nil
}

func (p *FileSystemWorkerClientServiceCloseUfsFileResult) writeField1(oprot thrift.TProtocol) (err error) {
	if p.IsSetE() {
		if err := oprot.WriteFieldBegin("e", thrift.STRUCT, 1); err != nil {
			return thrift.PrependError(fmt.Sprintf("%T write field begin error 1:e: ", p), err)
		}
		if err := p.E.Write(oprot); err != nil {
			return thrift.PrependError(fmt.Sprintf("%T error writing struct: ", p.E), err)
		}
		if err := oprot.WriteFieldEnd(); err != nil {
			return thrift.PrependError(fmt.Sprintf("%T write field end error 1:e: ", p), err)
		}
	}
	return err
}

func (p *FileSystemWorkerClientServiceCloseUfsFileResult) writeField2(oprot thrift.TProtocol) (err error) {
	if p.IsSetIoe() {
		if err := oprot.WriteFieldBegin("ioe", thrift.STRUCT, 2); err != nil {
			return thrift.PrependError(fmt.Sprintf("%T write field begin error 2:ioe: ", p), err)
		}
		if err := p.Ioe.Write(oprot); err != nil {
			return thrift.PrependError(fmt.Sprintf("%T error writing struct: ", p.Ioe), err)
		}
		if err := oprot.WriteFieldEnd(); err != nil {
			return thrift.PrependError(fmt.Sprintf("%T write field end error 2:ioe: ", p), err)
		}
	}
	return err
}

func (p *FileSystemWorkerClientServiceCloseUfsFileResult) String() string {
	if p == nil {
		return "<nil>"
	}
	return fmt.Sprintf("FileSystemWorkerClientServiceCloseUfsFileResult(%+v)", *p)
}

// Attributes:
//  - SessionId: the id of the current session
//  - TempUfsFileId: the worker specific file id of the ufs file
//  - Options: the options for completing the file
type FileSystemWorkerClientServiceCompleteUfsFileArgs struct {
	SessionId     int64                    `thrift:"sessionId,1" json:"sessionId"`
	TempUfsFileId int64                    `thrift:"tempUfsFileId,2" json:"tempUfsFileId"`
	Options       *CompleteUfsFileTOptions `thrift:"options,3" json:"options"`
}

func NewFileSystemWorkerClientServiceCompleteUfsFileArgs() *FileSystemWorkerClientServiceCompleteUfsFileArgs {
	return &FileSystemWorkerClientServiceCompleteUfsFileArgs{}
}

func (p *FileSystemWorkerClientServiceCompleteUfsFileArgs) GetSessionId() int64 {
	return p.SessionId
}

func (p *FileSystemWorkerClientServiceCompleteUfsFileArgs) GetTempUfsFileId() int64 {
	return p.TempUfsFileId
}

var FileSystemWorkerClientServiceCompleteUfsFileArgs_Options_DEFAULT *CompleteUfsFileTOptions

func (p *FileSystemWorkerClientServiceCompleteUfsFileArgs) GetOptions() *CompleteUfsFileTOptions {
	if !p.IsSetOptions() {
		return FileSystemWorkerClientServiceCompleteUfsFileArgs_Options_DEFAULT
	}
	return p.Options
}
func (p *FileSystemWorkerClientServiceCompleteUfsFileArgs) IsSetOptions() bool {
	return p.Options != nil
}

func (p *FileSystemWorkerClientServiceCompleteUfsFileArgs) Read(iprot thrift.TProtocol) error {
	if _, err := iprot.ReadStructBegin(); err != nil {
		return thrift.PrependError(fmt.Sprintf("%T read error: ", p), err)
	}

	for {
		_, fieldTypeId, fieldId, err := iprot.ReadFieldBegin()
		if err != nil {
			return thrift.PrependError(fmt.Sprintf("%T field %d read error: ", p, fieldId), err)
		}
		if fieldTypeId == thrift.STOP {
			break
		}
		switch fieldId {
		case 1:
			if err := p.readField1(iprot); err != nil {
				return err
			}
		case 2:
			if err := p.readField2(iprot); err != nil {
				return err
			}
		case 3:
			if err := p.readField3(iprot); err != nil {
				return err
			}
		default:
			if err := iprot.Skip(fieldTypeId); err != nil {
				return err
			}
		}
		if err := iprot.ReadFieldEnd(); err != nil {
			return err
		}
	}
	if err := iprot.ReadStructEnd(); err != nil {
		return thrift.PrependError(fmt.Sprintf("%T read struct end error: ", p), err)
	}
	return nil
}

func (p *FileSystemWorkerClientServiceCompleteUfsFileArgs) readField1(iprot thrift.TProtocol) error {
	if v, err := iprot.ReadI64(); err != nil {
		return thrift.PrependError("error reading field 1: ", err)
	} else {
		p.SessionId = v
	}
	return nil
}

func (p *FileSystemWorkerClientServiceCompleteUfsFileArgs) readField2(iprot thrift.TProtocol) error {
	if v, err := iprot.ReadI64(); err != nil {
		return thrift.PrependError("error reading field 2: ", err)
	} else {
		p.TempUfsFileId = v
	}
	return nil
}

func (p *FileSystemWorkerClientServiceCompleteUfsFileArgs) readField3(iprot thrift.TProtocol) error {
	p.Options = &CompleteUfsFileTOptions{}
	if err := p.Options.Read(iprot); err != nil {
		return thrift.PrependError(fmt.Sprintf("%T error reading struct: ", p.Options), err)
	}
	return nil
}

func (p *FileSystemWorkerClientServiceCompleteUfsFileArgs) Write(oprot thrift.TProtocol) error {
	if err := oprot.WriteStructBegin("completeUfsFile_args"); err != nil {
		return thrift.PrependError(fmt.Sprintf("%T write struct begin error: ", p), err)
	}
	if err := p.writeField1(oprot); err != nil {
		return err
	}
	if err := p.writeField2(oprot); err != nil {
		return err
	}
	if err := p.writeField3(oprot); err != nil {
		return err
	}
	if err := oprot.WriteFieldStop(); err != nil {
		return thrift.PrependError("write field stop error: ", err)
	}
	if err := oprot.WriteStructEnd(); err != nil {
		return thrift.PrependError("write struct stop error: ", err)
	}
	return nil
}

func (p *FileSystemWorkerClientServiceCompleteUfsFileArgs) writeField1(oprot thrift.TProtocol) (err error) {
	if err := oprot.WriteFieldBegin("sessionId", thrift.I64, 1); err != nil {
		return thrift.PrependError(fmt.Sprintf("%T write field begin error 1:sessionId: ", p), err)
	}
	if err := oprot.WriteI64(int64(p.SessionId)); err != nil {
		return thrift.PrependError(fmt.Sprintf("%T.sessionId (1) field write error: ", p), err)
	}
	if err := oprot.WriteFieldEnd(); err != nil {
		return thrift.PrependError(fmt.Sprintf("%T write field end error 1:sessionId: ", p), err)
	}
	return err
}

func (p *FileSystemWorkerClientServiceCompleteUfsFileArgs) writeField2(oprot thrift.TProtocol) (err error) {
	if err := oprot.WriteFieldBegin("tempUfsFileId", thrift.I64, 2); err != nil {
		return thrift.PrependError(fmt.Sprintf("%T write field begin error 2:tempUfsFileId: ", p), err)
	}
	if err := oprot.WriteI64(int64(p.TempUfsFileId)); err != nil {
		return thrift.PrependError(fmt.Sprintf("%T.tempUfsFileId (2) field write error: ", p), err)
	}
	if err := oprot.WriteFieldEnd(); err != nil {
		return thrift.PrependError(fmt.Sprintf("%T write field end error 2:tempUfsFileId: ", p), err)
	}
	return err
}

func (p *FileSystemWorkerClientServiceCompleteUfsFileArgs) writeField3(oprot thrift.TProtocol) (err error) {
	if err := oprot.WriteFieldBegin("options", thrift.STRUCT, 3); err != nil {
		return thrift.PrependError(fmt.Sprintf("%T write field begin error 3:options: ", p), err)
	}
	if err := p.Options.Write(oprot); err != nil {
		return thrift.PrependError(fmt.Sprintf("%T error writing struct: ", p.Options), err)
	}
	if err := oprot.WriteFieldEnd(); err != nil {
		return thrift.PrependError(fmt.Sprintf("%T write field end error 3:options: ", p), err)
	}
	return err
}

func (p *FileSystemWorkerClientServiceCompleteUfsFileArgs) String() string {
	if p == nil {
		return "<nil>"
	}
	return fmt.Sprintf("FileSystemWorkerClientServiceCompleteUfsFileArgs(%+v)", *p)
}

// Attributes:
//  - Success
//  - E
//  - Ioe
type FileSystemWorkerClientServiceCompleteUfsFileResult struct {
	Success *int64                       `thrift:"success,0" json:"success,omitempty"`
	E       *exception.AlluxioTException `thrift:"e,1" json:"e,omitempty"`
	Ioe     *exception.ThriftIOException `thrift:"ioe,2" json:"ioe,omitempty"`
}

func NewFileSystemWorkerClientServiceCompleteUfsFileResult() *FileSystemWorkerClientServiceCompleteUfsFileResult {
	return &FileSystemWorkerClientServiceCompleteUfsFileResult{}
}

var FileSystemWorkerClientServiceCompleteUfsFileResult_Success_DEFAULT int64

func (p *FileSystemWorkerClientServiceCompleteUfsFileResult) GetSuccess() int64 {
	if !p.IsSetSuccess() {
		return FileSystemWorkerClientServiceCompleteUfsFileResult_Success_DEFAULT
	}
	return *p.Success
}

var FileSystemWorkerClientServiceCompleteUfsFileResult_E_DEFAULT *exception.AlluxioTException

func (p *FileSystemWorkerClientServiceCompleteUfsFileResult) GetE() *exception.AlluxioTException {
	if !p.IsSetE() {
		return FileSystemWorkerClientServiceCompleteUfsFileResult_E_DEFAULT
	}
	return p.E
}

var FileSystemWorkerClientServiceCompleteUfsFileResult_Ioe_DEFAULT *exception.ThriftIOException

func (p *FileSystemWorkerClientServiceCompleteUfsFileResult) GetIoe() *exception.ThriftIOException {
	if !p.IsSetIoe() {
		return FileSystemWorkerClientServiceCompleteUfsFileResult_Ioe_DEFAULT
	}
	return p.Ioe
}
func (p *FileSystemWorkerClientServiceCompleteUfsFileResult) IsSetSuccess() bool {
	return p.Success != nil
}

func (p *FileSystemWorkerClientServiceCompleteUfsFileResult) IsSetE() bool {
	return p.E != nil
}

func (p *FileSystemWorkerClientServiceCompleteUfsFileResult) IsSetIoe() bool {
	return p.Ioe != nil
}

func (p *FileSystemWorkerClientServiceCompleteUfsFileResult) Read(iprot thrift.TProtocol) error {
	if _, err := iprot.ReadStructBegin(); err != nil {
		return thrift.PrependError(fmt.Sprintf("%T read error: ", p), err)
	}

	for {
		_, fieldTypeId, fieldId, err := iprot.ReadFieldBegin()
		if err != nil {
			return thrift.PrependError(fmt.Sprintf("%T field %d read error: ", p, fieldId), err)
		}
		if fieldTypeId == thrift.STOP {
			break
		}
		switch fieldId {
		case 0:
			if err := p.readField0(iprot); err != nil {
				return err
			}
		case 1:
			if err := p.readField1(iprot); err != nil {
				return err
			}
		case 2:
			if err := p.readField2(iprot); err != nil {
				return err
			}
		default:
			if err := iprot.Skip(fieldTypeId); err != nil {
				return err
			}
		}
		if err := iprot.ReadFieldEnd(); err != nil {
			return err
		}
	}
	if err := iprot.ReadStructEnd(); err != nil {
		return thrift.PrependError(fmt.Sprintf("%T read struct end error: ", p), err)
	}
	return nil
}

func (p *FileSystemWorkerClientServiceCompleteUfsFileResult) readField0(iprot thrift.TProtocol) error {
	if v, err := iprot.ReadI64(); err != nil {
		return thrift.PrependError("error reading field 0: ", err)
	} else {
		p.Success = &v
	}
	return nil
}

func (p *FileSystemWorkerClientServiceCompleteUfsFileResult) readField1(iprot thrift.TProtocol) error {
	p.E = &exception.AlluxioTException{}
	if err := p.E.Read(iprot); err != nil {
		return thrift.PrependError(fmt.Sprintf("%T error reading struct: ", p.E), err)
	}
	return nil
}

func (p *FileSystemWorkerClientServiceCompleteUfsFileResult) readField2(iprot thrift.TProtocol) error {
	p.Ioe = &exception.ThriftIOException{}
	if err := p.Ioe.Read(iprot); err != nil {
		return thrift.PrependError(fmt.Sprintf("%T error reading struct: ", p.Ioe), err)
	}
	return nil
}

func (p *FileSystemWorkerClientServiceCompleteUfsFileResult) Write(oprot thrift.TProtocol) error {
	if err := oprot.WriteStructBegin("completeUfsFile_result"); err != nil {
		return thrift.PrependError(fmt.Sprintf("%T write struct begin error: ", p), err)
	}
	if err := p.writeField0(oprot); err != nil {
		return err
	}
	if err := p.writeField1(oprot); err != nil {
		return err
	}
	if err := p.writeField2(oprot); err != nil {
		return err
	}
	if err := oprot.WriteFieldStop(); err != nil {
		return thrift.PrependError("write field stop error: ", err)
	}
	if err := oprot.WriteStructEnd(); err != nil {
		return thrift.PrependError("write struct stop error: ", err)
	}
	return nil
}

func (p *FileSystemWorkerClientServiceCompleteUfsFileResult) writeField0(oprot thrift.TProtocol) (err error) {
	if p.IsSetSuccess() {
		if err := oprot.WriteFieldBegin("success", thrift.I64, 0); err != nil {
			return thrift.PrependError(fmt.Sprintf("%T write field begin error 0:success: ", p), err)
		}
		if err := oprot.WriteI64(int64(*p.Success)); err != nil {
			return thrift.PrependError(fmt.Sprintf("%T.success (0) field write error: ", p), err)
		}
		if err := oprot.WriteFieldEnd(); err != nil {
			return thrift.PrependError(fmt.Sprintf("%T write field end error 0:success: ", p), err)
		}
	}
	return err
}

func (p *FileSystemWorkerClientServiceCompleteUfsFileResult) writeField1(oprot thrift.TProtocol) (err error) {
	if p.IsSetE() {
		if err := oprot.WriteFieldBegin("e", thrift.STRUCT, 1); err != nil {
			return thrift.PrependError(fmt.Sprintf("%T write field begin error 1:e: ", p), err)
		}
		if err := p.E.Write(oprot); err != nil {
			return thrift.PrependError(fmt.Sprintf("%T error writing struct: ", p.E), err)
		}
		if err := oprot.WriteFieldEnd(); err != nil {
			return thrift.PrependError(fmt.Sprintf("%T write field end error 1:e: ", p), err)
		}
	}
	return err
}

func (p *FileSystemWorkerClientServiceCompleteUfsFileResult) writeField2(oprot thrift.TProtocol) (err error) {
	if p.IsSetIoe() {
		if err := oprot.WriteFieldBegin("ioe", thrift.STRUCT, 2); err != nil {
			return thrift.PrependError(fmt.Sprintf("%T write field begin error 2:ioe: ", p), err)
		}
		if err := p.Ioe.Write(oprot); err != nil {
			return thrift.PrependError(fmt.Sprintf("%T error writing struct: ", p.Ioe), err)
		}
		if err := oprot.WriteFieldEnd(); err != nil {
			return thrift.PrependError(fmt.Sprintf("%T write field end error 2:ioe: ", p), err)
		}
	}
	return err
}

func (p *FileSystemWorkerClientServiceCompleteUfsFileResult) String() string {
	if p == nil {
		return "<nil>"
	}
	return fmt.Sprintf("FileSystemWorkerClientServiceCompleteUfsFileResult(%+v)", *p)
}

// Attributes:
//  - SessionId: the id of the current session
//  - UfsPath: the path of the file in the ufs
//  - Options: the options for creating the file
type FileSystemWorkerClientServiceCreateUfsFileArgs struct {
	SessionId int64                  `thrift:"sessionId,1" json:"sessionId"`
	UfsPath   string                 `thrift:"ufsPath,2" json:"ufsPath"`
	Options   *CreateUfsFileTOptions `thrift:"options,3" json:"options"`
}

func NewFileSystemWorkerClientServiceCreateUfsFileArgs() *FileSystemWorkerClientServiceCreateUfsFileArgs {
	return &FileSystemWorkerClientServiceCreateUfsFileArgs{}
}

func (p *FileSystemWorkerClientServiceCreateUfsFileArgs) GetSessionId() int64 {
	return p.SessionId
}

func (p *FileSystemWorkerClientServiceCreateUfsFileArgs) GetUfsPath() string {
	return p.UfsPath
}

var FileSystemWorkerClientServiceCreateUfsFileArgs_Options_DEFAULT *CreateUfsFileTOptions

func (p *FileSystemWorkerClientServiceCreateUfsFileArgs) GetOptions() *CreateUfsFileTOptions {
	if !p.IsSetOptions() {
		return FileSystemWorkerClientServiceCreateUfsFileArgs_Options_DEFAULT
	}
	return p.Options
}
func (p *FileSystemWorkerClientServiceCreateUfsFileArgs) IsSetOptions() bool {
	return p.Options != nil
}

func (p *FileSystemWorkerClientServiceCreateUfsFileArgs) Read(iprot thrift.TProtocol) error {
	if _, err := iprot.ReadStructBegin(); err != nil {
		return thrift.PrependError(fmt.Sprintf("%T read error: ", p), err)
	}

	for {
		_, fieldTypeId, fieldId, err := iprot.ReadFieldBegin()
		if err != nil {
			return thrift.PrependError(fmt.Sprintf("%T field %d read error: ", p, fieldId), err)
		}
		if fieldTypeId == thrift.STOP {
			break
		}
		switch fieldId {
		case 1:
			if err := p.readField1(iprot); err != nil {
				return err
			}
		case 2:
			if err := p.readField2(iprot); err != nil {
				return err
			}
		case 3:
			if err := p.readField3(iprot); err != nil {
				return err
			}
		default:
			if err := iprot.Skip(fieldTypeId); err != nil {
				return err
			}
		}
		if err := iprot.ReadFieldEnd(); err != nil {
			return err
		}
	}
	if err := iprot.ReadStructEnd(); err != nil {
		return thrift.PrependError(fmt.Sprintf("%T read struct end error: ", p), err)
	}
	return nil
}

func (p *FileSystemWorkerClientServiceCreateUfsFileArgs) readField1(iprot thrift.TProtocol) error {
	if v, err := iprot.ReadI64(); err != nil {
		return thrift.PrependError("error reading field 1: ", err)
	} else {
		p.SessionId = v
	}
	return nil
}

func (p *FileSystemWorkerClientServiceCreateUfsFileArgs) readField2(iprot thrift.TProtocol) error {
	if v, err := iprot.ReadString(); err != nil {
		return thrift.PrependError("error reading field 2: ", err)
	} else {
		p.UfsPath = v
	}
	return nil
}

func (p *FileSystemWorkerClientServiceCreateUfsFileArgs) readField3(iprot thrift.TProtocol) error {
	p.Options = &CreateUfsFileTOptions{}
	if err := p.Options.Read(iprot); err != nil {
		return thrift.PrependError(fmt.Sprintf("%T error reading struct: ", p.Options), err)
	}
	return nil
}

func (p *FileSystemWorkerClientServiceCreateUfsFileArgs) Write(oprot thrift.TProtocol) error {
	if err := oprot.WriteStructBegin("createUfsFile_args"); err != nil {
		return thrift.PrependError(fmt.Sprintf("%T write struct begin error: ", p), err)
	}
	if err := p.writeField1(oprot); err != nil {
		return err
	}
	if err := p.writeField2(oprot); err != nil {
		return err
	}
	if err := p.writeField3(oprot); err != nil {
		return err
	}
	if err := oprot.WriteFieldStop(); err != nil {
		return thrift.PrependError("write field stop error: ", err)
	}
	if err := oprot.WriteStructEnd(); err != nil {
		return thrift.PrependError("write struct stop error: ", err)
	}
	return nil
}

func (p *FileSystemWorkerClientServiceCreateUfsFileArgs) writeField1(oprot thrift.TProtocol) (err error) {
	if err := oprot.WriteFieldBegin("sessionId", thrift.I64, 1); err != nil {
		return thrift.PrependError(fmt.Sprintf("%T write field begin error 1:sessionId: ", p), err)
	}
	if err := oprot.WriteI64(int64(p.SessionId)); err != nil {
		return thrift.PrependError(fmt.Sprintf("%T.sessionId (1) field write error: ", p), err)
	}
	if err := oprot.WriteFieldEnd(); err != nil {
		return thrift.PrependError(fmt.Sprintf("%T write field end error 1:sessionId: ", p), err)
	}
	return err
}

func (p *FileSystemWorkerClientServiceCreateUfsFileArgs) writeField2(oprot thrift.TProtocol) (err error) {
	if err := oprot.WriteFieldBegin("ufsPath", thrift.STRING, 2); err != nil {
		return thrift.PrependError(fmt.Sprintf("%T write field begin error 2:ufsPath: ", p), err)
	}
	if err := oprot.WriteString(string(p.UfsPath)); err != nil {
		return thrift.PrependError(fmt.Sprintf("%T.ufsPath (2) field write error: ", p), err)
	}
	if err := oprot.WriteFieldEnd(); err != nil {
		return thrift.PrependError(fmt.Sprintf("%T write field end error 2:ufsPath: ", p), err)
	}
	return err
}

func (p *FileSystemWorkerClientServiceCreateUfsFileArgs) writeField3(oprot thrift.TProtocol) (err error) {
	if err := oprot.WriteFieldBegin("options", thrift.STRUCT, 3); err != nil {
		return thrift.PrependError(fmt.Sprintf("%T write field begin error 3:options: ", p), err)
	}
	if err := p.Options.Write(oprot); err != nil {
		return thrift.PrependError(fmt.Sprintf("%T error writing struct: ", p.Options), err)
	}
	if err := oprot.WriteFieldEnd(); err != nil {
		return thrift.PrependError(fmt.Sprintf("%T write field end error 3:options: ", p), err)
	}
	return err
}

func (p *FileSystemWorkerClientServiceCreateUfsFileArgs) String() string {
	if p == nil {
		return "<nil>"
	}
	return fmt.Sprintf("FileSystemWorkerClientServiceCreateUfsFileArgs(%+v)", *p)
}

// Attributes:
//  - Success
//  - E
//  - Ioe
type FileSystemWorkerClientServiceCreateUfsFileResult struct {
	Success *int64                       `thrift:"success,0" json:"success,omitempty"`
	E       *exception.AlluxioTException `thrift:"e,1" json:"e,omitempty"`
	Ioe     *exception.ThriftIOException `thrift:"ioe,2" json:"ioe,omitempty"`
}

func NewFileSystemWorkerClientServiceCreateUfsFileResult() *FileSystemWorkerClientServiceCreateUfsFileResult {
	return &FileSystemWorkerClientServiceCreateUfsFileResult{}
}

var FileSystemWorkerClientServiceCreateUfsFileResult_Success_DEFAULT int64

func (p *FileSystemWorkerClientServiceCreateUfsFileResult) GetSuccess() int64 {
	if !p.IsSetSuccess() {
		return FileSystemWorkerClientServiceCreateUfsFileResult_Success_DEFAULT
	}
	return *p.Success
}

var FileSystemWorkerClientServiceCreateUfsFileResult_E_DEFAULT *exception.AlluxioTException

func (p *FileSystemWorkerClientServiceCreateUfsFileResult) GetE() *exception.AlluxioTException {
	if !p.IsSetE() {
		return FileSystemWorkerClientServiceCreateUfsFileResult_E_DEFAULT
	}
	return p.E
}

var FileSystemWorkerClientServiceCreateUfsFileResult_Ioe_DEFAULT *exception.ThriftIOException

func (p *FileSystemWorkerClientServiceCreateUfsFileResult) GetIoe() *exception.ThriftIOException {
	if !p.IsSetIoe() {
		return FileSystemWorkerClientServiceCreateUfsFileResult_Ioe_DEFAULT
	}
	return p.Ioe
}
func (p *FileSystemWorkerClientServiceCreateUfsFileResult) IsSetSuccess() bool {
	return p.Success != nil
}

func (p *FileSystemWorkerClientServiceCreateUfsFileResult) IsSetE() bool {
	return p.E != nil
}

func (p *FileSystemWorkerClientServiceCreateUfsFileResult) IsSetIoe() bool {
	return p.Ioe != nil
}

func (p *FileSystemWorkerClientServiceCreateUfsFileResult) Read(iprot thrift.TProtocol) error {
	if _, err := iprot.ReadStructBegin(); err != nil {
		return thrift.PrependError(fmt.Sprintf("%T read error: ", p), err)
	}

	for {
		_, fieldTypeId, fieldId, err := iprot.ReadFieldBegin()
		if err != nil {
			return thrift.PrependError(fmt.Sprintf("%T field %d read error: ", p, fieldId), err)
		}
		if fieldTypeId == thrift.STOP {
			break
		}
		switch fieldId {
		case 0:
			if err := p.readField0(iprot); err != nil {
				return err
			}
		case 1:
			if err := p.readField1(iprot); err != nil {
				return err
			}
		case 2:
			if err := p.readField2(iprot); err != nil {
				return err
			}
		default:
			if err := iprot.Skip(fieldTypeId); err != nil {
				return err
			}
		}
		if err := iprot.ReadFieldEnd(); err != nil {
			return err
		}
	}
	if err := iprot.ReadStructEnd(); err != nil {
		return thrift.PrependError(fmt.Sprintf("%T read struct end error: ", p), err)
	}
	return nil
}

func (p *FileSystemWorkerClientServiceCreateUfsFileResult) readField0(iprot thrift.TProtocol) error {
	if v, err := iprot.ReadI64(); err != nil {
		return thrift.PrependError("error reading field 0: ", err)
	} else {
		p.Success = &v
	}
	return nil
}

func (p *FileSystemWorkerClientServiceCreateUfsFileResult) readField1(iprot thrift.TProtocol) error {
	p.E = &exception.AlluxioTException{}
	if err := p.E.Read(iprot); err != nil {
		return thrift.PrependError(fmt.Sprintf("%T error reading struct: ", p.E), err)
	}
	return nil
}

func (p *FileSystemWorkerClientServiceCreateUfsFileResult) readField2(iprot thrift.TProtocol) error {
	p.Ioe = &exception.ThriftIOException{}
	if err := p.Ioe.Read(iprot); err != nil {
		return thrift.PrependError(fmt.Sprintf("%T error reading struct: ", p.Ioe), err)
	}
	return nil
}

func (p *FileSystemWorkerClientServiceCreateUfsFileResult) Write(oprot thrift.TProtocol) error {
	if err := oprot.WriteStructBegin("createUfsFile_result"); err != nil {
		return thrift.PrependError(fmt.Sprintf("%T write struct begin error: ", p), err)
	}
	if err := p.writeField0(oprot); err != nil {
		return err
	}
	if err := p.writeField1(oprot); err != nil {
		return err
	}
	if err := p.writeField2(oprot); err != nil {
		return err
	}
	if err := oprot.WriteFieldStop(); err != nil {
		return thrift.PrependError("write field stop error: ", err)
	}
	if err := oprot.WriteStructEnd(); err != nil {
		return thrift.PrependError("write struct stop error: ", err)
	}
	return nil
}

func (p *FileSystemWorkerClientServiceCreateUfsFileResult) writeField0(oprot thrift.TProtocol) (err error) {
	if p.IsSetSuccess() {
		if err := oprot.WriteFieldBegin("success", thrift.I64, 0); err != nil {
			return thrift.PrependError(fmt.Sprintf("%T write field begin error 0:success: ", p), err)
		}
		if err := oprot.WriteI64(int64(*p.Success)); err != nil {
			return thrift.PrependError(fmt.Sprintf("%T.success (0) field write error: ", p), err)
		}
		if err := oprot.WriteFieldEnd(); err != nil {
			return thrift.PrependError(fmt.Sprintf("%T write field end error 0:success: ", p), err)
		}
	}
	return err
}

func (p *FileSystemWorkerClientServiceCreateUfsFileResult) writeField1(oprot thrift.TProtocol) (err error) {
	if p.IsSetE() {
		if err := oprot.WriteFieldBegin("e", thrift.STRUCT, 1); err != nil {
			return thrift.PrependError(fmt.Sprintf("%T write field begin error 1:e: ", p), err)
		}
		if err := p.E.Write(oprot); err != nil {
			return thrift.PrependError(fmt.Sprintf("%T error writing struct: ", p.E), err)
		}
		if err := oprot.WriteFieldEnd(); err != nil {
			return thrift.PrependError(fmt.Sprintf("%T write field end error 1:e: ", p), err)
		}
	}
	return err
}

func (p *FileSystemWorkerClientServiceCreateUfsFileResult) writeField2(oprot thrift.TProtocol) (err error) {
	if p.IsSetIoe() {
		if err := oprot.WriteFieldBegin("ioe", thrift.STRUCT, 2); err != nil {
			return thrift.PrependError(fmt.Sprintf("%T write field begin error 2:ioe: ", p), err)
		}
		if err := p.Ioe.Write(oprot); err != nil {
			return thrift.PrependError(fmt.Sprintf("%T error writing struct: ", p.Ioe), err)
		}
		if err := oprot.WriteFieldEnd(); err != nil {
			return thrift.PrependError(fmt.Sprintf("%T write field end error 2:ioe: ", p), err)
		}
	}
	return err
}

func (p *FileSystemWorkerClientServiceCreateUfsFileResult) String() string {
	if p == nil {
		return "<nil>"
	}
	return fmt.Sprintf("FileSystemWorkerClientServiceCreateUfsFileResult(%+v)", *p)
}

// Attributes:
//  - SessionId: the id of the current session
//  - UfsPath: the path of the file in the ufs
//  - Options: the options for opening the file
type FileSystemWorkerClientServiceOpenUfsFileArgs struct {
	SessionId int64                `thrift:"sessionId,1" json:"sessionId"`
	UfsPath   string               `thrift:"ufsPath,2" json:"ufsPath"`
	Options   *OpenUfsFileTOptions `thrift:"options,3" json:"options"`
}

func NewFileSystemWorkerClientServiceOpenUfsFileArgs() *FileSystemWorkerClientServiceOpenUfsFileArgs {
	return &FileSystemWorkerClientServiceOpenUfsFileArgs{}
}

func (p *FileSystemWorkerClientServiceOpenUfsFileArgs) GetSessionId() int64 {
	return p.SessionId
}

func (p *FileSystemWorkerClientServiceOpenUfsFileArgs) GetUfsPath() string {
	return p.UfsPath
}

var FileSystemWorkerClientServiceOpenUfsFileArgs_Options_DEFAULT *OpenUfsFileTOptions

func (p *FileSystemWorkerClientServiceOpenUfsFileArgs) GetOptions() *OpenUfsFileTOptions {
	if !p.IsSetOptions() {
		return FileSystemWorkerClientServiceOpenUfsFileArgs_Options_DEFAULT
	}
	return p.Options
}
func (p *FileSystemWorkerClientServiceOpenUfsFileArgs) IsSetOptions() bool {
	return p.Options != nil
}

func (p *FileSystemWorkerClientServiceOpenUfsFileArgs) Read(iprot thrift.TProtocol) error {
	if _, err := iprot.ReadStructBegin(); err != nil {
		return thrift.PrependError(fmt.Sprintf("%T read error: ", p), err)
	}

	for {
		_, fieldTypeId, fieldId, err := iprot.ReadFieldBegin()
		if err != nil {
			return thrift.PrependError(fmt.Sprintf("%T field %d read error: ", p, fieldId), err)
		}
		if fieldTypeId == thrift.STOP {
			break
		}
		switch fieldId {
		case 1:
			if err := p.readField1(iprot); err != nil {
				return err
			}
		case 2:
			if err := p.readField2(iprot); err != nil {
				return err
			}
		case 3:
			if err := p.readField3(iprot); err != nil {
				return err
			}
		default:
			if err := iprot.Skip(fieldTypeId); err != nil {
				return err
			}
		}
		if err := iprot.ReadFieldEnd(); err != nil {
			return err
		}
	}
	if err := iprot.ReadStructEnd(); err != nil {
		return thrift.PrependError(fmt.Sprintf("%T read struct end error: ", p), err)
	}
	return nil
}

func (p *FileSystemWorkerClientServiceOpenUfsFileArgs) readField1(iprot thrift.TProtocol) error {
	if v, err := iprot.ReadI64(); err != nil {
		return thrift.PrependError("error reading field 1: ", err)
	} else {
		p.SessionId = v
	}
	return nil
}

func (p *FileSystemWorkerClientServiceOpenUfsFileArgs) readField2(iprot thrift.TProtocol) error {
	if v, err := iprot.ReadString(); err != nil {
		return thrift.PrependError("error reading field 2: ", err)
	} else {
		p.UfsPath = v
	}
	return nil
}

func (p *FileSystemWorkerClientServiceOpenUfsFileArgs) readField3(iprot thrift.TProtocol) error {
	p.Options = &OpenUfsFileTOptions{}
	if err := p.Options.Read(iprot); err != nil {
		return thrift.PrependError(fmt.Sprintf("%T error reading struct: ", p.Options), err)
	}
	return nil
}

func (p *FileSystemWorkerClientServiceOpenUfsFileArgs) Write(oprot thrift.TProtocol) error {
	if err := oprot.WriteStructBegin("openUfsFile_args"); err != nil {
		return thrift.PrependError(fmt.Sprintf("%T write struct begin error: ", p), err)
	}
	if err := p.writeField1(oprot); err != nil {
		return err
	}
	if err := p.writeField2(oprot); err != nil {
		return err
	}
	if err := p.writeField3(oprot); err != nil {
		return err
	}
	if err := oprot.WriteFieldStop(); err != nil {
		return thrift.PrependError("write field stop error: ", err)
	}
	if err := oprot.WriteStructEnd(); err != nil {
		return thrift.PrependError("write struct stop error: ", err)
	}
	return nil
}

func (p *FileSystemWorkerClientServiceOpenUfsFileArgs) writeField1(oprot thrift.TProtocol) (err error) {
	if err := oprot.WriteFieldBegin("sessionId", thrift.I64, 1); err != nil {
		return thrift.PrependError(fmt.Sprintf("%T write field begin error 1:sessionId: ", p), err)
	}
	if err := oprot.WriteI64(int64(p.SessionId)); err != nil {
		return thrift.PrependError(fmt.Sprintf("%T.sessionId (1) field write error: ", p), err)
	}
	if err := oprot.WriteFieldEnd(); err != nil {
		return thrift.PrependError(fmt.Sprintf("%T write field end error 1:sessionId: ", p), err)
	}
	return err
}

func (p *FileSystemWorkerClientServiceOpenUfsFileArgs) writeField2(oprot thrift.TProtocol) (err error) {
	if err := oprot.WriteFieldBegin("ufsPath", thrift.STRING, 2); err != nil {
		return thrift.PrependError(fmt.Sprintf("%T write field begin error 2:ufsPath: ", p), err)
	}
	if err := oprot.WriteString(string(p.UfsPath)); err != nil {
		return thrift.PrependError(fmt.Sprintf("%T.ufsPath (2) field write error: ", p), err)
	}
	if err := oprot.WriteFieldEnd(); err != nil {
		return thrift.PrependError(fmt.Sprintf("%T write field end error 2:ufsPath: ", p), err)
	}
	return err
}

func (p *FileSystemWorkerClientServiceOpenUfsFileArgs) writeField3(oprot thrift.TProtocol) (err error) {
	if err := oprot.WriteFieldBegin("options", thrift.STRUCT, 3); err != nil {
		return thrift.PrependError(fmt.Sprintf("%T write field begin error 3:options: ", p), err)
	}
	if err := p.Options.Write(oprot); err != nil {
		return thrift.PrependError(fmt.Sprintf("%T error writing struct: ", p.Options), err)
	}
	if err := oprot.WriteFieldEnd(); err != nil {
		return thrift.PrependError(fmt.Sprintf("%T write field end error 3:options: ", p), err)
	}
	return err
}

func (p *FileSystemWorkerClientServiceOpenUfsFileArgs) String() string {
	if p == nil {
		return "<nil>"
	}
	return fmt.Sprintf("FileSystemWorkerClientServiceOpenUfsFileArgs(%+v)", *p)
}

// Attributes:
//  - Success
//  - E
//  - Ioe
type FileSystemWorkerClientServiceOpenUfsFileResult struct {
	Success *int64                       `thrift:"success,0" json:"success,omitempty"`
	E       *exception.AlluxioTException `thrift:"e,1" json:"e,omitempty"`
	Ioe     *exception.ThriftIOException `thrift:"ioe,2" json:"ioe,omitempty"`
}

func NewFileSystemWorkerClientServiceOpenUfsFileResult() *FileSystemWorkerClientServiceOpenUfsFileResult {
	return &FileSystemWorkerClientServiceOpenUfsFileResult{}
}

var FileSystemWorkerClientServiceOpenUfsFileResult_Success_DEFAULT int64

func (p *FileSystemWorkerClientServiceOpenUfsFileResult) GetSuccess() int64 {
	if !p.IsSetSuccess() {
		return FileSystemWorkerClientServiceOpenUfsFileResult_Success_DEFAULT
	}
	return *p.Success
}

var FileSystemWorkerClientServiceOpenUfsFileResult_E_DEFAULT *exception.AlluxioTException

func (p *FileSystemWorkerClientServiceOpenUfsFileResult) GetE() *exception.AlluxioTException {
	if !p.IsSetE() {
		return FileSystemWorkerClientServiceOpenUfsFileResult_E_DEFAULT
	}
	return p.E
}

var FileSystemWorkerClientServiceOpenUfsFileResult_Ioe_DEFAULT *exception.ThriftIOException

func (p *FileSystemWorkerClientServiceOpenUfsFileResult) GetIoe() *exception.ThriftIOException {
	if !p.IsSetIoe() {
		return FileSystemWorkerClientServiceOpenUfsFileResult_Ioe_DEFAULT
	}
	return p.Ioe
}
func (p *FileSystemWorkerClientServiceOpenUfsFileResult) IsSetSuccess() bool {
	return p.Success != nil
}

func (p *FileSystemWorkerClientServiceOpenUfsFileResult) IsSetE() bool {
	return p.E != nil
}

func (p *FileSystemWorkerClientServiceOpenUfsFileResult) IsSetIoe() bool {
	return p.Ioe != nil
}

func (p *FileSystemWorkerClientServiceOpenUfsFileResult) Read(iprot thrift.TProtocol) error {
	if _, err := iprot.ReadStructBegin(); err != nil {
		return thrift.PrependError(fmt.Sprintf("%T read error: ", p), err)
	}

	for {
		_, fieldTypeId, fieldId, err := iprot.ReadFieldBegin()
		if err != nil {
			return thrift.PrependError(fmt.Sprintf("%T field %d read error: ", p, fieldId), err)
		}
		if fieldTypeId == thrift.STOP {
			break
		}
		switch fieldId {
		case 0:
			if err := p.readField0(iprot); err != nil {
				return err
			}
		case 1:
			if err := p.readField1(iprot); err != nil {
				return err
			}
		case 2:
			if err := p.readField2(iprot); err != nil {
				return err
			}
		default:
			if err := iprot.Skip(fieldTypeId); err != nil {
				return err
			}
		}
		if err := iprot.ReadFieldEnd(); err != nil {
			return err
		}
	}
	if err := iprot.ReadStructEnd(); err != nil {
		return thrift.PrependError(fmt.Sprintf("%T read struct end error: ", p), err)
	}
	return nil
}

func (p *FileSystemWorkerClientServiceOpenUfsFileResult) readField0(iprot thrift.TProtocol) error {
	if v, err := iprot.ReadI64(); err != nil {
		return thrift.PrependError("error reading field 0: ", err)
	} else {
		p.Success = &v
	}
	return nil
}

func (p *FileSystemWorkerClientServiceOpenUfsFileResult) readField1(iprot thrift.TProtocol) error {
	p.E = &exception.AlluxioTException{}
	if err := p.E.Read(iprot); err != nil {
		return thrift.PrependError(fmt.Sprintf("%T error reading struct: ", p.E), err)
	}
	return nil
}

func (p *FileSystemWorkerClientServiceOpenUfsFileResult) readField2(iprot thrift.TProtocol) error {
	p.Ioe = &exception.ThriftIOException{}
	if err := p.Ioe.Read(iprot); err != nil {
		return thrift.PrependError(fmt.Sprintf("%T error reading struct: ", p.Ioe), err)
	}
	return nil
}

func (p *FileSystemWorkerClientServiceOpenUfsFileResult) Write(oprot thrift.TProtocol) error {
	if err := oprot.WriteStructBegin("openUfsFile_result"); err != nil {
		return thrift.PrependError(fmt.Sprintf("%T write struct begin error: ", p), err)
	}
	if err := p.writeField0(oprot); err != nil {
		return err
	}
	if err := p.writeField1(oprot); err != nil {
		return err
	}
	if err := p.writeField2(oprot); err != nil {
		return err
	}
	if err := oprot.WriteFieldStop(); err != nil {
		return thrift.PrependError("write field stop error: ", err)
	}
	if err := oprot.WriteStructEnd(); err != nil {
		return thrift.PrependError("write struct stop error: ", err)
	}
	return nil
}

func (p *FileSystemWorkerClientServiceOpenUfsFileResult) writeField0(oprot thrift.TProtocol) (err error) {
	if p.IsSetSuccess() {
		if err := oprot.WriteFieldBegin("success", thrift.I64, 0); err != nil {
			return thrift.PrependError(fmt.Sprintf("%T write field begin error 0:success: ", p), err)
		}
		if err := oprot.WriteI64(int64(*p.Success)); err != nil {
			return thrift.PrependError(fmt.Sprintf("%T.success (0) field write error: ", p), err)
		}
		if err := oprot.WriteFieldEnd(); err != nil {
			return thrift.PrependError(fmt.Sprintf("%T write field end error 0:success: ", p), err)
		}
	}
	return err
}

func (p *FileSystemWorkerClientServiceOpenUfsFileResult) writeField1(oprot thrift.TProtocol) (err error) {
	if p.IsSetE() {
		if err := oprot.WriteFieldBegin("e", thrift.STRUCT, 1); err != nil {
			return thrift.PrependError(fmt.Sprintf("%T write field begin error 1:e: ", p), err)
		}
		if err := p.E.Write(oprot); err != nil {
			return thrift.PrependError(fmt.Sprintf("%T error writing struct: ", p.E), err)
		}
		if err := oprot.WriteFieldEnd(); err != nil {
			return thrift.PrependError(fmt.Sprintf("%T write field end error 1:e: ", p), err)
		}
	}
	return err
}

func (p *FileSystemWorkerClientServiceOpenUfsFileResult) writeField2(oprot thrift.TProtocol) (err error) {
	if p.IsSetIoe() {
		if err := oprot.WriteFieldBegin("ioe", thrift.STRUCT, 2); err != nil {
			return thrift.PrependError(fmt.Sprintf("%T write field begin error 2:ioe: ", p), err)
		}
		if err := p.Ioe.Write(oprot); err != nil {
			return thrift.PrependError(fmt.Sprintf("%T error writing struct: ", p.Ioe), err)
		}
		if err := oprot.WriteFieldEnd(); err != nil {
			return thrift.PrependError(fmt.Sprintf("%T write field end error 2:ioe: ", p), err)
		}
	}
	return err
}

func (p *FileSystemWorkerClientServiceOpenUfsFileResult) String() string {
	if p == nil {
		return "<nil>"
	}
	return fmt.Sprintf("FileSystemWorkerClientServiceOpenUfsFileResult(%+v)", *p)
}

// Attributes:
//  - SessionId: the id of the current session
//  - Metrics: the client metrics
type FileSystemWorkerClientServiceSessionHeartbeatArgs struct {
	SessionId int64   `thrift:"sessionId,1" json:"sessionId"`
	Metrics   []int64 `thrift:"metrics,2" json:"metrics"`
}

func NewFileSystemWorkerClientServiceSessionHeartbeatArgs() *FileSystemWorkerClientServiceSessionHeartbeatArgs {
	return &FileSystemWorkerClientServiceSessionHeartbeatArgs{}
}

func (p *FileSystemWorkerClientServiceSessionHeartbeatArgs) GetSessionId() int64 {
	return p.SessionId
}

func (p *FileSystemWorkerClientServiceSessionHeartbeatArgs) GetMetrics() []int64 {
	return p.Metrics
}
func (p *FileSystemWorkerClientServiceSessionHeartbeatArgs) Read(iprot thrift.TProtocol) error {
	if _, err := iprot.ReadStructBegin(); err != nil {
		return thrift.PrependError(fmt.Sprintf("%T read error: ", p), err)
	}

	for {
		_, fieldTypeId, fieldId, err := iprot.ReadFieldBegin()
		if err != nil {
			return thrift.PrependError(fmt.Sprintf("%T field %d read error: ", p, fieldId), err)
		}
		if fieldTypeId == thrift.STOP {
			break
		}
		switch fieldId {
		case 1:
			if err := p.readField1(iprot); err != nil {
				return err
			}
		case 2:
			if err := p.readField2(iprot); err != nil {
				return err
			}
		default:
			if err := iprot.Skip(fieldTypeId); err != nil {
				return err
			}
		}
		if err := iprot.ReadFieldEnd(); err != nil {
			return err
		}
	}
	if err := iprot.ReadStructEnd(); err != nil {
		return thrift.PrependError(fmt.Sprintf("%T read struct end error: ", p), err)
	}
	return nil
}

func (p *FileSystemWorkerClientServiceSessionHeartbeatArgs) readField1(iprot thrift.TProtocol) error {
	if v, err := iprot.ReadI64(); err != nil {
		return thrift.PrependError("error reading field 1: ", err)
	} else {
		p.SessionId = v
	}
	return nil
}

func (p *FileSystemWorkerClientServiceSessionHeartbeatArgs) readField2(iprot thrift.TProtocol) error {
	_, size, err := iprot.ReadListBegin()
	if err != nil {
		return thrift.PrependError("error reading list begin: ", err)
	}
	tSlice := make([]int64, 0, size)
	p.Metrics = tSlice
	for i := 0; i < size; i++ {
		var _elem13 int64
		if v, err := iprot.ReadI64(); err != nil {
			return thrift.PrependError("error reading field 0: ", err)
		} else {
			_elem13 = v
		}
		p.Metrics = append(p.Metrics, _elem13)
	}
	if err := iprot.ReadListEnd(); err != nil {
		return thrift.PrependError("error reading list end: ", err)
	}
	return nil
}

func (p *FileSystemWorkerClientServiceSessionHeartbeatArgs) Write(oprot thrift.TProtocol) error {
	if err := oprot.WriteStructBegin("sessionHeartbeat_args"); err != nil {
		return thrift.PrependError(fmt.Sprintf("%T write struct begin error: ", p), err)
	}
	if err := p.writeField1(oprot); err != nil {
		return err
	}
	if err := p.writeField2(oprot); err != nil {
		return err
	}
	if err := oprot.WriteFieldStop(); err != nil {
		return thrift.PrependError("write field stop error: ", err)
	}
	if err := oprot.WriteStructEnd(); err != nil {
		return thrift.PrependError("write struct stop error: ", err)
	}
	return nil
}

func (p *FileSystemWorkerClientServiceSessionHeartbeatArgs) writeField1(oprot thrift.TProtocol) (err error) {
	if err := oprot.WriteFieldBegin("sessionId", thrift.I64, 1); err != nil {
		return thrift.PrependError(fmt.Sprintf("%T write field begin error 1:sessionId: ", p), err)
	}
	if err := oprot.WriteI64(int64(p.SessionId)); err != nil {
		return thrift.PrependError(fmt.Sprintf("%T.sessionId (1) field write error: ", p), err)
	}
	if err := oprot.WriteFieldEnd(); err != nil {
		return thrift.PrependError(fmt.Sprintf("%T write field end error 1:sessionId: ", p), err)
	}
	return err
}

func (p *FileSystemWorkerClientServiceSessionHeartbeatArgs) writeField2(oprot thrift.TProtocol) (err error) {
	if err := oprot.WriteFieldBegin("metrics", thrift.LIST, 2); err != nil {
		return thrift.PrependError(fmt.Sprintf("%T write field begin error 2:metrics: ", p), err)
	}
	if err := oprot.WriteListBegin(thrift.I64, len(p.Metrics)); err != nil {
		return thrift.PrependError("error writing list begin: ", err)
	}
	for _, v := range p.Metrics {
		if err := oprot.WriteI64(int64(v)); err != nil {
			return thrift.PrependError(fmt.Sprintf("%T. (0) field write error: ", p), err)
		}
	}
	if err := oprot.WriteListEnd(); err != nil {
		return thrift.PrependError("error writing list end: ", err)
	}
	if err := oprot.WriteFieldEnd(); err != nil {
		return thrift.PrependError(fmt.Sprintf("%T write field end error 2:metrics: ", p), err)
	}
	return err
}

func (p *FileSystemWorkerClientServiceSessionHeartbeatArgs) String() string {
	if p == nil {
		return "<nil>"
	}
	return fmt.Sprintf("FileSystemWorkerClientServiceSessionHeartbeatArgs(%+v)", *p)
}

type FileSystemWorkerClientServiceSessionHeartbeatResult struct {
}

func NewFileSystemWorkerClientServiceSessionHeartbeatResult() *FileSystemWorkerClientServiceSessionHeartbeatResult {
	return &FileSystemWorkerClientServiceSessionHeartbeatResult{}
}

func (p *FileSystemWorkerClientServiceSessionHeartbeatResult) Read(iprot thrift.TProtocol) error {
	if _, err := iprot.ReadStructBegin(); err != nil {
		return thrift.PrependError(fmt.Sprintf("%T read error: ", p), err)
	}

	for {
		_, fieldTypeId, fieldId, err := iprot.ReadFieldBegin()
		if err != nil {
			return thrift.PrependError(fmt.Sprintf("%T field %d read error: ", p, fieldId), err)
		}
		if fieldTypeId == thrift.STOP {
			break
		}
		if err := iprot.Skip(fieldTypeId); err != nil {
			return err
		}
		if err := iprot.ReadFieldEnd(); err != nil {
			return err
		}
	}
	if err := iprot.ReadStructEnd(); err != nil {
		return thrift.PrependError(fmt.Sprintf("%T read struct end error: ", p), err)
	}
	return nil
}

func (p *FileSystemWorkerClientServiceSessionHeartbeatResult) Write(oprot thrift.TProtocol) error {
	if err := oprot.WriteStructBegin("sessionHeartbeat_result"); err != nil {
		return thrift.PrependError(fmt.Sprintf("%T write struct begin error: ", p), err)
	}
	if err := oprot.WriteFieldStop(); err != nil {
		return thrift.PrependError("write field stop error: ", err)
	}
	if err := oprot.WriteStructEnd(); err != nil {
		return thrift.PrependError("write struct stop error: ", err)
	}
	return nil
}

func (p *FileSystemWorkerClientServiceSessionHeartbeatResult) String() string {
	if p == nil {
		return "<nil>"
	}
	return fmt.Sprintf("FileSystemWorkerClientServiceSessionHeartbeatResult(%+v)", *p)
}
